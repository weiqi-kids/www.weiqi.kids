"use strict";(globalThis.webpackChunktemp_docusaurus=globalThis.webpackChunktemp_docusaurus||[]).push([[3709],{14078(e,n,a){a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"tech/deep-dive/source-code","title":"Guia del codigo fuente de KataGo","description":"Estructura del codigo de KataGo, modulos principales y diseno de arquitectura","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/tech/deep-dive/source-code.md","sourceDirName":"tech/deep-dive","slug":"/tech/deep-dive/source-code","permalink":"/es/docs/tech/deep-dive/source-code","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tech/deep-dive/source-code.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Guia del codigo fuente de KataGo","description":"Estructura del codigo de KataGo, modulos principales y diseno de arquitectura"},"sidebar":"tutorialSidebar","previous":{"title":"Para quienes desean profundizar","permalink":"/es/docs/tech/deep-dive/"},"next":{"title":"An\xe1lisis del mecanismo de entrenamiento de KataGo","permalink":"/es/docs/tech/deep-dive/training"}}');var o=a(62615),r=a(30416);const s={sidebar_position:2,title:"Guia del codigo fuente de KataGo",description:"Estructura del codigo de KataGo, modulos principales y diseno de arquitectura"},d="Guia del codigo fuente de KataGo",l={},c=[{value:"Obtener el codigo fuente",id:"obtener-el-codigo-fuente",level:2},{value:"Estructura de directorios",id:"estructura-de-directorios",level:2},{value:"Analisis de modulos principales",id:"analisis-de-modulos-principales",level:2},{value:"1. game/ \u2014 Reglas de Go",id:"1-game--reglas-de-go",level:3},{value:"board.h / board.cpp",id:"boardh--boardcpp",level:4},{value:"rules.h / rules.cpp",id:"rulesh--rulescpp",level:4},{value:"2. search/ \u2014 Busqueda MCTS",id:"2-search--busqueda-mcts",level:3},{value:"search.h / search.cpp",id:"searchh--searchcpp",level:4},{value:"searchparams.h",id:"searchparamsh",level:4},{value:"3. neuralnet/ \u2014 Inferencia de red neuronal",id:"3-neuralnet--inferencia-de-red-neuronal",level:3},{value:"nninputs.h / nninputs.cpp",id:"nninputsh--nninputscpp",level:4},{value:"nneval.h / nneval.cpp",id:"nnevalh--nnevalcpp",level:4},{value:"4. command/ \u2014 Procesamiento de comandos",id:"4-command--procesamiento-de-comandos",level:3},{value:"gtp.cpp",id:"gtpcpp",level:4},{value:"analysis.cpp",id:"analysiscpp",level:4},{value:"Codigo de entrenamiento Python",id:"codigo-de-entrenamiento-python",level:2},{value:"model.py \u2014 Arquitectura de red",id:"modelpy--arquitectura-de-red",level:3},{value:"train.py \u2014 Ciclo de entrenamiento",id:"trainpy--ciclo-de-entrenamiento",level:3},{value:"Implementacion de algoritmos clave",id:"implementacion-de-algoritmos-clave",level:2},{value:"Formula de seleccion PUCT",id:"formula-de-seleccion-puct",level:3},{value:"Perdida virtual",id:"perdida-virtual",level:3},{value:"Compilacion y depuracion",id:"compilacion-y-depuracion",level:2},{value:"Compilacion (modo Debug)",id:"compilacion-modo-debug",level:3},{value:"Pruebas unitarias",id:"pruebas-unitarias",level:3},{value:"Tecnicas de depuracion",id:"tecnicas-de-depuracion",level:3},{value:"Lectura adicional",id:"lectura-adicional",level:2}];function t(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"guia-del-codigo-fuente-de-katago",children:"Guia del codigo fuente de KataGo"})}),"\n",(0,o.jsx)(n.p,{children:"Este articulo te guia a traves de la estructura del codigo de KataGo, ideal para ingenieros que desean investigar a fondo o contribuir codigo."}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"obtener-el-codigo-fuente",children:"Obtener el codigo fuente"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/lightvector/KataGo.git\ncd KataGo\n"})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"estructura-de-directorios",children:"Estructura de directorios"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"KataGo/\n\u251c\u2500\u2500 cpp/                    # Motor principal en C++\n\u2502   \u251c\u2500\u2500 main.cpp            # Punto de entrada principal\n\u2502   \u251c\u2500\u2500 command/            # Procesamiento de comandos\n\u2502   \u251c\u2500\u2500 core/               # Utilidades principales\n\u2502   \u251c\u2500\u2500 game/               # Reglas de Go\n\u2502   \u251c\u2500\u2500 search/             # Busqueda MCTS\n\u2502   \u251c\u2500\u2500 neuralnet/          # Inferencia de red neuronal\n\u2502   \u251c\u2500\u2500 dataio/             # I/O de datos\n\u2502   \u2514\u2500\u2500 tests/              # Pruebas unitarias\n\u2502\n\u251c\u2500\u2500 python/                 # Codigo de entrenamiento Python\n\u2502   \u251c\u2500\u2500 train.py            # Programa principal de entrenamiento\n\u2502   \u251c\u2500\u2500 model.py            # Definicion de arquitectura de red\n\u2502   \u251c\u2500\u2500 data/               # Procesamiento de datos\n\u2502   \u2514\u2500\u2500 configs/            # Configuraciones de entrenamiento\n\u2502\n\u2514\u2500\u2500 docs/                   # Documentacion\n"})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"analisis-de-modulos-principales",children:"Analisis de modulos principales"}),"\n",(0,o.jsx)(n.h3,{id:"1-game--reglas-de-go",children:"1. game/ \u2014 Reglas de Go"}),"\n",(0,o.jsx)(n.p,{children:"Implementacion completa de las reglas de Go."}),"\n",(0,o.jsx)(n.h4,{id:"boardh--boardcpp",children:"board.h / board.cpp"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Representacion del estado del tablero\nclass Board {\npublic:\n    static constexpr int MAX_BOARD_SIZE = 19;\n\n    // Estado del tablero\n    Color colors[MAX_ARR_SIZE];  // Color de cada posicion\n    Chain chains[MAX_ARR_SIZE];  // Informacion de cadenas\n\n    // Operaciones principales\n    bool playMove(Loc loc, Player pla);  // Jugar un movimiento\n    bool isLegal(Loc loc, Player pla);   // Verificar legalidad\n    void calculateArea(Color* area);      // Calcular territorio\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Correspondencia con animaciones"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A2 Modelo de red: Estructura de datos del tablero"}),"\n",(0,o.jsx)(n.li,{children:"A6 Region conectada: Representacion de cadenas (Chain)"}),"\n",(0,o.jsx)(n.li,{children:"A7 Calculo de libertades: Seguimiento de libertades"}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"rulesh--rulescpp",children:"rules.h / rules.cpp"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Soporte multi-reglas\nstruct Rules {\n    enum KoRule { SIMPLE_KO, POSITIONAL_KO, SITUATIONAL_KO };\n    enum ScoringRule { TERRITORY_SCORING, AREA_SCORING };\n    enum TaxRule { NO_TAX, TAX_SEKI, TAX_ALL };\n\n    KoRule koRule;\n    ScoringRule scoringRule;\n    TaxRule taxRule;\n    float komi;\n\n    // Mapeo de nombres de reglas\n    static Rules parseRules(const std::string& name);\n};\n"})}),"\n",(0,o.jsx)(n.p,{children:"Reglas soportadas:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"chinese"}),": Reglas chinas (conteo de area)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"japanese"}),": Reglas japonesas (conteo de territorio)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"korean"}),": Reglas coreanas"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"aga"}),": Reglas americanas"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"tromp-taylor"}),": Reglas Tromp-Taylor"]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h3,{id:"2-search--busqueda-mcts",children:"2. search/ \u2014 Busqueda MCTS"}),"\n",(0,o.jsx)(n.p,{children:"Implementacion de Monte Carlo Tree Search."}),"\n",(0,o.jsx)(n.h4,{id:"searchh--searchcpp",children:"search.h / search.cpp"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"class Search {\npublic:\n    // Busqueda principal\n    void runWholeSearch(Player pla);\n\n    // Pasos de MCTS\n    void selectNode();           // Seleccionar nodo\n    void expandNode();           // Expandir nodo\n    void evaluateNode();         // Evaluacion con red neuronal\n    void backpropValue();        // Retropropagar actualizacion\n\n    // Obtener resultados\n    Loc getChosenMove();\n    std::vector<MoveInfo> getSortedMoveInfos();\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Correspondencia con animaciones"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"C5 Cuatro pasos de MCTS: Corresponde a select \u2192 expand \u2192 evaluate \u2192 backprop"}),"\n",(0,o.jsxs)(n.li,{children:["E4 Formula PUCT: Implementada en ",(0,o.jsx)(n.code,{children:"selectNode()"})]}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"searchparamsh",children:"searchparams.h"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"struct SearchParams {\n    // Control de busqueda\n    int64_t maxVisits;          // Visitas maximas\n    double maxTime;             // Tiempo maximo\n\n    // Parametros PUCT\n    double cpuctExploration;    // Constante de exploracion\n    double cpuctBase;\n\n    // Perdida virtual\n    int virtualLoss;\n\n    // Ruido en nodo raiz\n    double rootNoiseEnabled;\n    double rootDirichletAlpha;\n};\n"})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h3,{id:"3-neuralnet--inferencia-de-red-neuronal",children:"3. neuralnet/ \u2014 Inferencia de red neuronal"}),"\n",(0,o.jsx)(n.p,{children:"Motor de inferencia de red neuronal."}),"\n",(0,o.jsx)(n.h4,{id:"nninputsh--nninputscpp",children:"nninputs.h / nninputs.cpp"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Caracteristicas de entrada de red neuronal\nclass NNInputs {\npublic:\n    // Planos de caracteristicas\n    static constexpr int NUM_FEATURES = 22;\n\n    // Rellenar caracteristicas\n    static void fillFeatures(\n        const Board& board,\n        const BoardHistory& hist,\n        float* features\n    );\n};\n"})}),"\n",(0,o.jsx)(n.p,{children:"Las caracteristicas de entrada incluyen:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Posicion de piedras negras, posicion de piedras blancas"}),"\n",(0,o.jsx)(n.li,{children:"Numero de libertades (1, 2, 3+)"}),"\n",(0,o.jsx)(n.li,{children:"Movimientos historicos"}),"\n",(0,o.jsx)(n.li,{children:"Codificacion de reglas"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Correspondencia con animaciones"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A10 Apilamiento historico: Entrada multi-frame"}),"\n",(0,o.jsx)(n.li,{children:"A11 Mascara de movimientos legales: Filtrado de movimientos prohibidos"}),"\n"]}),"\n",(0,o.jsx)(n.h4,{id:"nnevalh--nnevalcpp",children:"nneval.h / nneval.cpp"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Resultado de evaluacion de red neuronal\nstruct NNOutput {\n    // Salida de Policy (362 posiciones, incluye pass)\n    float policyProbs[NNPos::MAX_NN_POLICY_SIZE];\n\n    // Salida de Value\n    float winProb;       // Probabilidad de victoria\n    float lossProb;      // Probabilidad de derrota\n    float noResultProb;  // Probabilidad de empate\n\n    // Salidas auxiliares\n    float scoreMean;     // Prediccion de puntos\n    float scoreStdev;    // Desviacion estandar de puntos\n    float lead;          // Puntos de ventaja\n\n    // Prediccion de territorio\n    float ownership[NNPos::MAX_BOARD_AREA];\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Correspondencia con animaciones"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"E1 Red de politica: policyProbs"}),"\n",(0,o.jsx)(n.li,{children:"E2 Red de valor: winProb, scoreMean"}),"\n",(0,o.jsx)(n.li,{children:"E3 Red de doble cabeza: Diseno de salida multiple"}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h3,{id:"4-command--procesamiento-de-comandos",children:"4. command/ \u2014 Procesamiento de comandos"}),"\n",(0,o.jsx)(n.p,{children:"Implementacion de diferentes modos de ejecucion."}),"\n",(0,o.jsx)(n.h4,{id:"gtpcpp",children:"gtp.cpp"}),"\n",(0,o.jsx)(n.p,{children:"Implementacion del modo GTP (Go Text Protocol):"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'void MainCmds::gtp(const std::vector<std::string>& args) {\n    // Analisis y ejecucion de comandos\n    while(true) {\n        std::string line;\n        std::getline(std::cin, line);\n\n        if(line == "name") {\n            respond("KataGo");\n        }\n        else if(line.find("play") == 0) {\n            // Procesar comando de jugar\n        }\n        else if(line.find("genmove") == 0) {\n            // Ejecutar busqueda y devolver mejor movimiento\n        }\n        // ... otros comandos\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h4,{id:"analysiscpp",children:"analysis.cpp"}),"\n",(0,o.jsx)(n.p,{children:"Implementacion del Analysis Engine:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"void MainCmds::analysis(const std::vector<std::string>& args) {\n    while(true) {\n        // Leer solicitud JSON\n        std::string line;\n        std::getline(std::cin, line);\n        json query = json::parse(line);\n\n        // Configurar estado del tablero\n        Board board = setupBoard(query);\n\n        // Ejecutar analisis\n        Search search(...);\n        search.runWholeSearch();\n\n        // Salida de respuesta JSON\n        json response = formatResponse(search);\n        std::cout << response.dump() << std::endl;\n    }\n}\n"})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"codigo-de-entrenamiento-python",children:"Codigo de entrenamiento Python"}),"\n",(0,o.jsx)(n.h3,{id:"modelpy--arquitectura-de-red",children:"model.py \u2014 Arquitectura de red"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"class Model(nn.Module):\n    def __init__(self, config):\n        super().__init__()\n\n        # Convolucion inicial\n        self.initial_conv = nn.Conv2d(\n            in_channels=config.input_features,\n            out_channels=config.trunk_channels,\n            kernel_size=3, padding=1\n        )\n\n        # Torre residual\n        self.trunk = nn.ModuleList([\n            ResidualBlock(config.trunk_channels)\n            for _ in range(config.num_blocks)\n        ])\n\n        # Cabezas de salida\n        self.policy_head = PolicyHead(config)\n        self.value_head = ValueHead(config)\n        self.ownership_head = OwnershipHead(config)\n\n    def forward(self, x):\n        # Convolucion inicial\n        x = self.initial_conv(x)\n\n        # Torre residual\n        for block in self.trunk:\n            x = block(x)\n\n        # Salida multiple\n        policy = self.policy_head(x)\n        value = self.value_head(x)\n        ownership = self.ownership_head(x)\n\n        return policy, value, ownership\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Correspondencia con animaciones"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"D9 Operacion de convolucion: Conv2d"}),"\n",(0,o.jsx)(n.li,{children:"D12 Conexion residual: ResidualBlock"}),"\n",(0,o.jsx)(n.li,{children:"E11 Torre residual: estructura trunk"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"trainpy--ciclo-de-entrenamiento",children:"train.py \u2014 Ciclo de entrenamiento"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"def train_step(model, optimizer, batch):\n    # Propagacion hacia adelante\n    policy_pred, value_pred, ownership_pred = model(batch.inputs)\n\n    # Calcular perdida\n    policy_loss = cross_entropy(policy_pred, batch.policy_target)\n    value_loss = mse_loss(value_pred, batch.value_target)\n    ownership_loss = mse_loss(ownership_pred, batch.ownership_target)\n\n    total_loss = policy_loss + value_loss + ownership_loss\n\n    # Retropropagacion\n    optimizer.zero_grad()\n    total_loss.backward()\n    optimizer.step()\n\n    return total_loss.item()\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Correspondencia con animaciones"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"D3 Propagacion hacia adelante: model(batch.inputs)"}),"\n",(0,o.jsx)(n.li,{children:"D13 Retropropagacion: total_loss.backward()"}),"\n",(0,o.jsx)(n.li,{children:"K3 Adam: optimizer.step()"}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"implementacion-de-algoritmos-clave",children:"Implementacion de algoritmos clave"}),"\n",(0,o.jsx)(n.h3,{id:"formula-de-seleccion-puct",children:"Formula de seleccion PUCT"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// search.cpp\ndouble Search::getPUCTScore(const SearchNode* node, int moveIdx) {\n    double Q = node->getChildValue(moveIdx);\n    double P = node->getChildPolicy(moveIdx);\n    double N_parent = node->visits;\n    double N_child = node->getChildVisits(moveIdx);\n\n    double exploration = params.cpuctExploration;\n    double cpuct = exploration * sqrt(N_parent) / (1.0 + N_child);\n\n    return Q + cpuct * P;\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"perdida-virtual",children:"Perdida virtual"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Evitar que multiples hilos seleccionen el mismo nodo\nvoid Search::applyVirtualLoss(SearchNode* node) {\n    node->virtualLoss += params.virtualLoss;\n}\n\nvoid Search::removeVirtualLoss(SearchNode* node) {\n    node->virtualLoss -= params.virtualLoss;\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Correspondencia con animaciones"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"C9 Perdida virtual: Tecnica de busqueda paralela"}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"compilacion-y-depuracion",children:"Compilacion y depuracion"}),"\n",(0,o.jsx)(n.h3,{id:"compilacion-modo-debug",children:"Compilacion (modo Debug)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"cd cpp\nmkdir build && cd build\ncmake .. -DUSE_BACKEND=OPENCL -DCMAKE_BUILD_TYPE=Debug\nmake -j$(nproc)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"pruebas-unitarias",children:"Pruebas unitarias"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"./katago runtests\n"})}),"\n",(0,o.jsx)(n.h3,{id:"tecnicas-de-depuracion",children:"Tecnicas de depuracion"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Habilitar logs detallados\n#define SEARCH_DEBUG 1\n\n// Agregar punto de interrupcion en la busqueda\nif(node->visits > 1000) {\n    // Establecer breakpoint para inspeccionar estado de busqueda\n}\n"})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"lectura-adicional",children:"Lectura adicional"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"../training",children:"Analisis del mecanismo de entrenamiento de KataGo"})," \u2014 Proceso completo de entrenamiento"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"../contributing",children:"Participar en la comunidad de codigo abierto"})," \u2014 Guia de contribucion"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/docs/animations/",children:"Hoja de referencia de conceptos"})," \u2014 Referencia de 109 conceptos"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(t,{...e})}):t(e)}},30416(e,n,a){a.d(n,{R:()=>s,x:()=>d});var i=a(59471);const o={},r=i.createContext(o);function s(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);