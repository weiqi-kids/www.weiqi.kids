"use strict";(globalThis.webpackChunktemp_docusaurus=globalThis.webpackChunktemp_docusaurus||[]).push([[3069],{46353(e,n,s){s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>l,toc:()=>a});const l=JSON.parse('{"id":"for-engineers/deep-dive/neural-network","title":"Neural Network Architecture","description":"In-depth analysis of KataGo\'s neural network design, input features, and multi-head output architecture","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/for-engineers/deep-dive/neural-network.md","sourceDirName":"for-engineers/deep-dive","slug":"/for-engineers/deep-dive/neural-network","permalink":"/en/docs/for-engineers/deep-dive/neural-network","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/for-engineers/deep-dive/neural-network.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Neural Network Architecture","description":"In-depth analysis of KataGo\'s neural network design, input features, and multi-head output architecture"},"sidebar":"tutorialSidebar","previous":{"title":"Contributing to Open Source","permalink":"/en/docs/for-engineers/deep-dive/contributing"},"next":{"title":"MCTS Implementation Details","permalink":"/en/docs/for-engineers/deep-dive/mcts-implementation"}}');var r=s(62615),i=s(30416);const t={sidebar_position:4,title:"Neural Network Architecture",description:"In-depth analysis of KataGo's neural network design, input features, and multi-head output architecture"},o="Neural Network Architecture",d={},a=[{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Input Feature Encoding",id:"input-feature-encoding",level:2},{value:"Feature Planes Overview",id:"feature-planes-overview",level:3},{value:"History State Stacking",id:"history-state-stacking",level:3},{value:"Rules Encoding",id:"rules-encoding",level:3},{value:"Backbone Network: Residual Tower",id:"backbone-network-residual-tower",level:2},{value:"Residual Block Structure",id:"residual-block-structure",level:3},{value:"Code Example",id:"code-example",level:3},{value:"Global Pooling Layer",id:"global-pooling-layer",level:3},{value:"Output Head Design",id:"output-head-design",level:2},{value:"Policy Head",id:"policy-head",level:3},{value:"Value Head",id:"value-head",level:3},{value:"Score Head",id:"score-head",level:3},{value:"Ownership Head",id:"ownership-head",level:3},{value:"Differences from AlphaZero",id:"differences-from-alphazero",level:2},{value:"Model Sizes",id:"model-sizes",level:2},{value:"Complete Network Implementation",id:"complete-network-implementation",level:2},{value:"Further Reading",id:"further-reading",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"neural-network-architecture",children:"Neural Network Architecture"})}),"\n",(0,r.jsx)(n.p,{children:"This article provides an in-depth analysis of KataGo's complete neural network architecture, from input feature encoding to multi-head output design."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,r.jsxs)(n.p,{children:["KataGo uses a ",(0,r.jsx)(n.strong,{children:"single neural network with multi-head output"})," design:"]}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TB\n    Input["Input Features (19\xd719\xd722)"]\n    Conv["Initial Conv Layer<br/>256 filters"]\n    Tower["Residual Tower<br/>20-60 res blocks<br/>+ Global Pooling"]\n\n    Input --\x3e Conv --\x3e Tower\n\n    Tower --\x3e Policy["Policy Head"]\n    Tower --\x3e Value["Value Head"]\n    Tower --\x3e Score["Score Head"]\n    Tower --\x3e Owner["Ownership Head"]\n\n    Policy --\x3e P_Out["362 probs<br/>(incl pass)"]\n    Value --\x3e V_Out["Win rate<br/>(-1~+1)"]\n    Score --\x3e S_Out["Score<br/>(points)"]\n    Owner --\x3e O_Out["361 ownership<br/>(-1~+1)"]'}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"input-feature-encoding",children:"Input Feature Encoding"}),"\n",(0,r.jsx)(n.h3,{id:"feature-planes-overview",children:"Feature Planes Overview"}),"\n",(0,r.jsxs)(n.p,{children:["KataGo uses ",(0,r.jsx)(n.strong,{children:"22 feature planes"})," (19\xd719\xd722), where each plane is a 19\xd719 matrix:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Plane"}),(0,r.jsx)(n.th,{children:"Content"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"Own stones"}),(0,r.jsx)(n.td,{children:"1 = own stone present, 0 = none"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"Opponent stones"}),(0,r.jsx)(n.td,{children:"1 = opponent stone present, 0 = none"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"Empty points"}),(0,r.jsx)(n.td,{children:"1 = empty, 0 = has stone"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"3-10"}),(0,r.jsx)(n.td,{children:"History states"}),(0,r.jsx)(n.td,{children:"Board changes from past 8 moves"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"11"}),(0,r.jsx)(n.td,{children:"Ko point"}),(0,r.jsx)(n.td,{children:"1 = ko forbidden, 0 = playable"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"12-17"}),(0,r.jsx)(n.td,{children:"Liberty encoding"}),(0,r.jsx)(n.td,{children:"Chains with 1, 2, 3... liberties"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"18-21"}),(0,r.jsx)(n.td,{children:"Rules encoding"}),(0,r.jsx)(n.td,{children:"Chinese/Japanese rules, komi, etc."})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"history-state-stacking",children:"History State Stacking"}),"\n",(0,r.jsxs)(n.p,{children:["To let the neural network understand ",(0,r.jsx)(n.strong,{children:"dynamic changes"})," in the position, KataGo stacks the past 8 board states:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# History state encoding (concept)\ndef encode_history(game_history, current_player):\n    features = []\n\n    for t in range(8):  # Past 8 moves\n        if t < len(game_history):\n            board = game_history[-(t+1)]\n            # Encode own/opponent stones at that time\n            features.append(encode_board(board, current_player))\n        else:\n            # Insufficient history, fill with zeros\n            features.append(np.zeros((19, 19)))\n\n    return np.stack(features, axis=0)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"rules-encoding",children:"Rules Encoding"}),"\n",(0,r.jsx)(n.p,{children:"KataGo supports multiple rulesets, communicated to the neural network through feature planes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Rules encoding (concept)\ndef encode_rules(rules, komi):\n    rule_features = np.zeros((4, 19, 19))\n\n    # Rule type (one-hot)\n    if rules == "chinese":\n        rule_features[0] = 1.0\n    elif rules == "japanese":\n        rule_features[1] = 1.0\n\n    # Komi normalization\n    normalized_komi = komi / 15.0  # Normalize to [-1, 1]\n    rule_features[2] = normalized_komi\n\n    # Current player\n    rule_features[3] = 1.0 if current_player == BLACK else 0.0\n\n    return rule_features\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"backbone-network-residual-tower",children:"Backbone Network: Residual Tower"}),"\n",(0,r.jsx)(n.h3,{id:"residual-block-structure",children:"Residual Block Structure"}),"\n",(0,r.jsxs)(n.p,{children:["KataGo uses ",(0,r.jsx)(n.strong,{children:"Pre-activation ResNet"})," structure:"]}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TB\n    Input["Input x"]\n    BN1["BatchNorm"]\n    ReLU1["ReLU"]\n    Conv1["Conv 3\xd73"]\n    BN2["BatchNorm"]\n    ReLU2["ReLU"]\n    Conv2["Conv 3\xd73"]\n    Add(("+"))\n    Output["Output"]\n\n    Input --\x3e BN1 --\x3e ReLU1 --\x3e Conv1 --\x3e BN2 --\x3e ReLU2 --\x3e Conv2 --\x3e Add\n    Input --\x3e|"residual connection"| Add\n    Add --\x3e Output'}),"\n",(0,r.jsx)(n.h3,{id:"code-example",children:"Code Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class ResidualBlock(nn.Module):\n    def __init__(self, channels):\n        super().__init__()\n        self.bn1 = nn.BatchNorm2d(channels)\n        self.conv1 = nn.Conv2d(channels, channels, 3, padding=1)\n        self.bn2 = nn.BatchNorm2d(channels)\n        self.conv2 = nn.Conv2d(channels, channels, 3, padding=1)\n\n    def forward(self, x):\n        residual = x\n\n        out = self.bn1(x)\n        out = F.relu(out)\n        out = self.conv1(out)\n\n        out = self.bn2(out)\n        out = F.relu(out)\n        out = self.conv2(out)\n\n        return out + residual  # Residual connection\n"})}),"\n",(0,r.jsx)(n.h3,{id:"global-pooling-layer",children:"Global Pooling Layer"}),"\n",(0,r.jsxs)(n.p,{children:["One of KataGo's key innovations: adding ",(0,r.jsx)(n.strong,{children:"global pooling"})," in residual blocks, allowing the network to see global information:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class GlobalPoolingBlock(nn.Module):\n    def __init__(self, channels):\n        super().__init__()\n        self.conv = nn.Conv2d(channels, channels, 3, padding=1)\n        self.fc = nn.Linear(channels, channels)\n\n    def forward(self, x):\n        # Local path\n        local = self.conv(x)\n\n        # Global path\n        global_pool = x.mean(dim=[2, 3])  # Global average pooling\n        global_fc = self.fc(global_pool)\n        global_broadcast = global_fc.unsqueeze(2).unsqueeze(3)\n        global_broadcast = global_broadcast.expand(-1, -1, 19, 19)\n\n        # Fusion\n        return local + global_broadcast\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Why is global pooling needed?"})}),"\n",(0,r.jsx)(n.p,{children:'Traditional convolution only sees locally (3\xd73 receptive field). Even with many stacked layers, global information perception remains limited. Global pooling lets the network directly "see":'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Stone count differences across the board"}),"\n",(0,r.jsx)(n.li,{children:"Global influence distribution"}),"\n",(0,r.jsx)(n.li,{children:"Overall position assessment"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"output-head-design",children:"Output Head Design"}),"\n",(0,r.jsx)(n.h3,{id:"policy-head",children:"Policy Head"}),"\n",(0,r.jsx)(n.p,{children:"Outputs the move probability for each position:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class PolicyHead(nn.Module):\n    def __init__(self, in_channels):\n        super().__init__()\n        self.conv = nn.Conv2d(in_channels, 2, 1)  # 1\xd71 convolution\n        self.bn = nn.BatchNorm2d(2)\n        self.fc = nn.Linear(2 * 19 * 19, 362)  # 361 + pass\n\n    def forward(self, x):\n        out = F.relu(self.bn(self.conv(x)))\n        out = out.view(out.size(0), -1)\n        out = self.fc(out)\n        return F.softmax(out, dim=1)  # Probability distribution\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output format"}),": 362-dimensional vector"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Indices 0-360: Move probability for 361 board positions"}),"\n",(0,r.jsx)(n.li,{children:"Index 361: Pass probability"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"value-head",children:"Value Head"}),"\n",(0,r.jsx)(n.p,{children:"Outputs the win rate for the current position:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class ValueHead(nn.Module):\n    def __init__(self, in_channels):\n        super().__init__()\n        self.conv = nn.Conv2d(in_channels, 1, 1)\n        self.bn = nn.BatchNorm2d(1)\n        self.fc1 = nn.Linear(19 * 19, 256)\n        self.fc2 = nn.Linear(256, 1)\n\n    def forward(self, x):\n        out = F.relu(self.bn(self.conv(x)))\n        out = out.view(out.size(0), -1)\n        out = F.relu(self.fc1(out))\n        out = torch.tanh(self.fc2(out))  # Output -1 to +1\n        return out\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output format"}),": Single value [-1, +1]"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"+1: Own side certain win"}),"\n",(0,r.jsx)(n.li,{children:"-1: Opponent certain win"}),"\n",(0,r.jsx)(n.li,{children:"0: Even position"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"score-head",children:"Score Head"}),"\n",(0,r.jsx)(n.p,{children:"KataGo-specific, predicts the final score difference:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class ScoreHead(nn.Module):\n    def __init__(self, in_channels):\n        super().__init__()\n        self.conv = nn.Conv2d(in_channels, 1, 1)\n        self.bn = nn.BatchNorm2d(1)\n        self.fc1 = nn.Linear(19 * 19, 256)\n        self.fc2 = nn.Linear(256, 1)\n\n    def forward(self, x):\n        out = F.relu(self.bn(self.conv(x)))\n        out = out.view(out.size(0), -1)\n        out = F.relu(self.fc1(out))\n        out = self.fc2(out)  # Unbounded output\n        return out\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output format"}),": Single value (points)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Positive: Own side leading"}),"\n",(0,r.jsx)(n.li,{children:"Negative: Opponent leading"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"ownership-head",children:"Ownership Head"}),"\n",(0,r.jsx)(n.p,{children:"Predicts final ownership of each point:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class OwnershipHead(nn.Module):\n    def __init__(self, in_channels):\n        super().__init__()\n        self.conv1 = nn.Conv2d(in_channels, 32, 1)\n        self.bn = nn.BatchNorm2d(32)\n        self.conv2 = nn.Conv2d(32, 1, 1)\n\n    def forward(self, x):\n        out = F.relu(self.bn(self.conv1(x)))\n        out = torch.tanh(self.conv2(out))  # Each point -1 to +1\n        return out.view(out.size(0), -1)  # Flatten to 361\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output format"}),": 361-dimensional vector, each value in [-1, +1]"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"+1: Point belongs to own territory"}),"\n",(0,r.jsx)(n.li,{children:"-1: Point belongs to opponent's territory"}),"\n",(0,r.jsx)(n.li,{children:"0: Neutral or disputed area"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"differences-from-alphazero",children:"Differences from AlphaZero"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Aspect"}),(0,r.jsx)(n.th,{children:"AlphaZero"}),(0,r.jsx)(n.th,{children:"KataGo"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Output heads"})}),(0,r.jsx)(n.td,{children:"2 (Policy + Value)"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.strong,{children:"4"})," (+ Score + Ownership)"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Global pooling"})}),(0,r.jsx)(n.td,{children:"None"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Yes"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Input features"})}),(0,r.jsx)(n.td,{children:"17 planes"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.strong,{children:"22 planes"})," (incl. rules encoding)"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Residual blocks"})}),(0,r.jsx)(n.td,{children:"Standard ResNet"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Pre-activation + Global Pooling"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Multi-rule support"})}),(0,r.jsx)(n.td,{children:"None"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.strong,{children:"Yes"})," (via feature encoding)"]})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"model-sizes",children:"Model Sizes"}),"\n",(0,r.jsx)(n.p,{children:"KataGo provides models at different scales:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Model"}),(0,r.jsx)(n.th,{children:"Residual Blocks"}),(0,r.jsx)(n.th,{children:"Channels"}),(0,r.jsx)(n.th,{children:"Parameters"}),(0,r.jsx)(n.th,{children:"Use Case"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"b10c128"}),(0,r.jsx)(n.td,{children:"10"}),(0,r.jsx)(n.td,{children:"128"}),(0,r.jsx)(n.td,{children:"~5M"}),(0,r.jsx)(n.td,{children:"CPU, quick testing"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"b18c384"}),(0,r.jsx)(n.td,{children:"18"}),(0,r.jsx)(n.td,{children:"384"}),(0,r.jsx)(n.td,{children:"~75M"}),(0,r.jsx)(n.td,{children:"Regular GPU"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"b40c256"}),(0,r.jsx)(n.td,{children:"40"}),(0,r.jsx)(n.td,{children:"256"}),(0,r.jsx)(n.td,{children:"~95M"}),(0,r.jsx)(n.td,{children:"High-end GPU"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"b60c320"}),(0,r.jsx)(n.td,{children:"60"}),(0,r.jsx)(n.td,{children:"320"}),(0,r.jsx)(n.td,{children:"~200M"}),(0,r.jsx)(n.td,{children:"Top-tier GPU"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Naming convention"}),": ",(0,r.jsx)(n.code,{children:"b{num_blocks}c{channels}"})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"complete-network-implementation",children:"Complete Network Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class KataGoNetwork(nn.Module):\n    def __init__(self, num_blocks=18, channels=384):\n        super().__init__()\n\n        # Initial convolution\n        self.initial_conv = nn.Conv2d(22, channels, 3, padding=1)\n        self.initial_bn = nn.BatchNorm2d(channels)\n\n        # Residual tower\n        self.residual_blocks = nn.ModuleList([\n            ResidualBlock(channels) for _ in range(num_blocks)\n        ])\n\n        # Global pooling blocks (insert one every few residual blocks)\n        self.global_pooling_blocks = nn.ModuleList([\n            GlobalPoolingBlock(channels) for _ in range(num_blocks // 6)\n        ])\n\n        # Output heads\n        self.policy_head = PolicyHead(channels)\n        self.value_head = ValueHead(channels)\n        self.score_head = ScoreHead(channels)\n        self.ownership_head = OwnershipHead(channels)\n\n    def forward(self, x):\n        # Initial convolution\n        out = F.relu(self.initial_bn(self.initial_conv(x)))\n\n        # Residual tower\n        gp_idx = 0\n        for i, block in enumerate(self.residual_blocks):\n            out = block(out)\n\n            # Insert global pooling every 6 residual blocks\n            if (i + 1) % 6 == 0 and gp_idx < len(self.global_pooling_blocks):\n                out = self.global_pooling_blocks[gp_idx](out)\n                gp_idx += 1\n\n        # Output heads\n        policy = self.policy_head(out)\n        value = self.value_head(out)\n        score = self.score_head(out)\n        ownership = self.ownership_head(out)\n\n        return {\n            'policy': policy,\n            'value': value,\n            'score': score,\n            'ownership': ownership\n        }\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"../mcts-implementation",children:"MCTS Implementation Details"})," \u2014 Combining search with neural networks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"../training",children:"KataGo Training Mechanism"})," \u2014 How networks are trained"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"../papers",children:"Key Papers Guide"})," \u2014 Mathematical derivations from original papers"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},30416(e,n,s){s.d(n,{R:()=>t,x:()=>o});var l=s(59471);const r={},i=l.createContext(r);function t(e){const n=l.useContext(i);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),l.createElement(i.Provider,{value:n},e.children)}}}]);