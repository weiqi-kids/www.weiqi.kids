"use strict";(self.webpackChunktemp_docusaurus=self.webpackChunktemp_docusaurus||[]).push([[2498],{1879:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"for-engineers/katago-source/architecture","title":"Source Code Architecture","description":"This article provides an in-depth analysis of KataGo\'s source code structure to help you understand its internal implementation. Whether you want to contribute code, modify features, or apply its techniques to your own projects, this is essential reference material.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/for-engineers/katago-source/architecture.md","sourceDirName":"for-engineers/katago-source","slug":"/for-engineers/katago-source/architecture","permalink":"/en/docs/for-engineers/katago-source/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/for-engineers/katago-source/architecture.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Source Code Architecture"},"sidebar":"tutorialSidebar","previous":{"title":"Common Commands","permalink":"/en/docs/for-engineers/katago-source/commands"}}');var o=a(3420),t=a(5521);const i={sidebar_position:3,title:"Source Code Architecture"},s="KataGo Source Code Architecture",l={},c=[{value:"Project Directory Structure",id:"project-directory-structure",level:2},{value:"cpp/ Directory Details",id:"cpp-directory-details",level:3},{value:"Neural Network Architecture",id:"neural-network-architecture",level:2},{value:"Network Structure Overview",id:"network-structure-overview",level:3},{value:"Input Features (nninputs.cpp)",id:"input-features-nninputscpp",level:3},{value:"Global Pooling Branch",id:"global-pooling-branch",level:3},{value:"Output Heads",id:"output-heads",level:3},{value:"Search Engine Implementation",id:"search-engine-implementation",level:2},{value:"MCTS Core Classes",id:"mcts-core-classes",level:3},{value:"Search Node Structure",id:"search-node-structure",level:3},{value:"PUCT Selection Algorithm",id:"puct-selection-algorithm",level:3},{value:"Parallel Search Implementation",id:"parallel-search-implementation",level:3},{value:"Virtual Loss",id:"virtual-loss",level:3},{value:"Training Process Overview",id:"training-process-overview",level:2},{value:"Training Data Generation",id:"training-data-generation",level:3},{value:"Self-play (cpp/command/selfplay.cpp)",id:"self-play-cppcommandselfplaycpp",level:3},{value:"Training Data Format",id:"training-data-format",level:3},{value:"Python Training Program (python/train.py)",id:"python-training-program-pythontrainpy",level:3},{value:"Model Definition (python/model.py)",id:"model-definition-pythonmodelpy",level:3},{value:"Key Data Structures",id:"key-data-structures",level:2},{value:"Board (game/board.h)",id:"board-gameboardh",level:3},{value:"BoardHistory (game/boardhistory.h)",id:"boardhistory-gameboardhistoryh",level:3},{value:"NNOutput (neuralnet/nneval.h)",id:"nnoutput-neuralnetnnevalh",level:3},{value:"Development and Debugging",id:"development-and-debugging",level:2},{value:"Build Debug Version",id:"build-debug-version",level:3},{value:"Run Unit Tests",id:"run-unit-tests",level:3},{value:"Common Debugging Methods",id:"common-debugging-methods",level:3},{value:"Performance Analysis",id:"performance-analysis",level:3},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"katago-source-code-architecture",children:"KataGo Source Code Architecture"})}),"\n",(0,o.jsx)(n.p,{children:"This article provides an in-depth analysis of KataGo's source code structure to help you understand its internal implementation. Whether you want to contribute code, modify features, or apply its techniques to your own projects, this is essential reference material."}),"\n",(0,o.jsx)(n.h2,{id:"project-directory-structure",children:"Project Directory Structure"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"KataGo/\n\u251c\u2500\u2500 cpp/                    # C++ core code\n\u2502   \u251c\u2500\u2500 main.cpp           # Main program entry\n\u2502   \u251c\u2500\u2500 command/           # Various execution modes\n\u2502   \u251c\u2500\u2500 core/              # Core utility classes\n\u2502   \u251c\u2500\u2500 game/              # Go rules and board\n\u2502   \u251c\u2500\u2500 search/            # MCTS search engine\n\u2502   \u251c\u2500\u2500 neuralnet/         # Neural network interface\n\u2502   \u251c\u2500\u2500 dataio/            # Data I/O\n\u2502   \u251c\u2500\u2500 configs/           # Example configuration files\n\u2502   \u2514\u2500\u2500 tests/             # Unit tests\n\u251c\u2500\u2500 python/                 # Python training code\n\u2502   \u251c\u2500\u2500 train.py           # Training main program\n\u2502   \u251c\u2500\u2500 model.py           # Model definition\n\u2502   \u251c\u2500\u2500 data_processing_pytorch.py\n\u2502   \u2514\u2500\u2500 configs/           # Training configurations\n\u251c\u2500\u2500 docs/                   # Documentation\n\u2514\u2500\u2500 scripts/               # Helper scripts\n"})}),"\n",(0,o.jsx)(n.h3,{id:"cpp-directory-details",children:"cpp/ Directory Details"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"cpp/\n\u251c\u2500\u2500 main.cpp                # Program entry, parses command line args\n\u251c\u2500\u2500 command/\n\u2502   \u251c\u2500\u2500 gtp.cpp            # GTP protocol implementation\n\u2502   \u251c\u2500\u2500 analysis.cpp       # Analysis Engine implementation\n\u2502   \u251c\u2500\u2500 benchmark.cpp      # Benchmark testing\n\u2502   \u251c\u2500\u2500 genconfig.cpp      # Config file generation\n\u2502   \u2514\u2500\u2500 selfplay.cpp       # Self-play\n\u251c\u2500\u2500 core/\n\u2502   \u251c\u2500\u2500 global.h           # Global constants and settings\n\u2502   \u251c\u2500\u2500 hash.h             # Zobrist hashing\n\u2502   \u251c\u2500\u2500 rand.h             # Random number generation\n\u2502   \u251c\u2500\u2500 logger.h           # Logging system\n\u2502   \u251c\u2500\u2500 config_parser.h    # Config file parsing\n\u2502   \u2514\u2500\u2500 threadsafe*.h      # Thread-safe utilities\n\u251c\u2500\u2500 game/\n\u2502   \u251c\u2500\u2500 board.h/cpp        # Board representation and basic operations\n\u2502   \u251c\u2500\u2500 rules.h/cpp        # Go rules\n\u2502   \u251c\u2500\u2500 boardhistory.h/cpp # Game history\n\u2502   \u2514\u2500\u2500 graphhash.h/cpp    # Position hashing\n\u251c\u2500\u2500 search/\n\u2502   \u251c\u2500\u2500 search.h/cpp       # Search engine main class\n\u2502   \u251c\u2500\u2500 searchnode.h/cpp   # Search tree nodes\n\u2502   \u251c\u2500\u2500 searchparams.h     # Search parameters\n\u2502   \u251c\u2500\u2500 mutexpool.h        # Lock pool\n\u2502   \u251c\u2500\u2500 searchresults.h    # Search results\n\u2502   \u2514\u2500\u2500 asyncbot.h/cpp     # Asynchronous bot\n\u251c\u2500\u2500 neuralnet/\n\u2502   \u251c\u2500\u2500 nninputs.h/cpp     # Neural network input features\n\u2502   \u251c\u2500\u2500 nneval.h/cpp       # Neural network evaluation\n\u2502   \u251c\u2500\u2500 nninterface.h      # Backend abstract interface\n\u2502   \u251c\u2500\u2500 cudabackend.cpp    # CUDA backend\n\u2502   \u251c\u2500\u2500 openclbackend.cpp  # OpenCL backend\n\u2502   \u251c\u2500\u2500 eigenbackend.cpp   # Eigen(CPU) backend\n\u2502   \u2514\u2500\u2500 modelversion.h     # Model version management\n\u2514\u2500\u2500 dataio/\n    \u251c\u2500\u2500 sgf.h/cpp          # SGF file handling\n    \u251c\u2500\u2500 numpywrite.h/cpp   # NumPy format output\n    \u2514\u2500\u2500 trainingwrite.h/cpp # Training data writing\n"})}),"\n",(0,o.jsx)(n.h2,{id:"neural-network-architecture",children:"Neural Network Architecture"}),"\n",(0,o.jsx)(n.h3,{id:"network-structure-overview",children:"Network Structure Overview"}),"\n",(0,o.jsx)(n.mermaid,{value:'graph TD\n    subgraph KataGoNN["KataGo Neural Network Architecture"]\n        Input["Input Layer<br/>(22 feature planes \xd7 19 \xd7 19)"]\n        InitConv["Initial Conv Layer<br/>3\xd73, C channels"]\n\n        subgraph ResBlocks["Residual Blocks \xd7 N"]\n            ResBlock["BatchNorm \u2192 ReLU \u2192 Conv 3\xd73<br/>BatchNorm \u2192 ReLU \u2192 Conv 3\xd73<br/>+ Global Pooling Branch<br/>+ Skip Connection"]\n        end\n\n        PolicyHead["Policy Head"]\n        ValueHead["Value Head"]\n        OtherHeads["Other Heads"]\n\n        Input --\x3e InitConv\n        InitConv --\x3e ResBlocks\n        ResBlocks --\x3e PolicyHead\n        ResBlocks --\x3e ValueHead\n        ResBlocks --\x3e OtherHeads\n    end'}),"\n",(0,o.jsx)(n.h3,{id:"input-features-nninputscpp",children:"Input Features (nninputs.cpp)"}),"\n",(0,o.jsx)(n.p,{children:"KataGo uses 22 feature planes as input:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Main input feature categories\nenum {\n  // Board state\n  INPUT_FEATURE_STONE_OUR,      // Our stones\n  INPUT_FEATURE_STONE_OPP,      // Opponent stones\n\n  // Liberty-related (1-8 liberties)\n  INPUT_FEATURE_LIBERTIES_1,\n  INPUT_FEATURE_LIBERTIES_2,\n  // ...\n  INPUT_FEATURE_LIBERTIES_8_OR_MORE,\n\n  // History state\n  INPUT_FEATURE_LAST_MOVE,      // Last move position\n  INPUT_FEATURE_SECOND_LAST_MOVE,\n\n  // Rules-related\n  INPUT_FEATURE_KOMI,           // Komi\n  INPUT_FEATURE_RULES,          // Rules encoding\n  // ...\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"global-pooling-branch",children:"Global Pooling Branch"}),"\n",(0,o.jsx)(n.p,{children:"One of KataGo's innovations is adding global pooling to residual blocks:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Simplified global pooling implementation concept\nclass GlobalPoolingResBlock {\npublic:\n  void forward(Tensor& x) {\n    // Standard residual path\n    Tensor regular_out = regular_conv_path(x);\n\n    // Global pooling path\n    Tensor global_mean = global_avg_pool(x);  // [batch, C]\n    Tensor global_max = global_max_pool(x);    // [batch, C]\n    Tensor global_features = concat(global_mean, global_max);\n\n    // Process global features\n    global_features = dense_layer(global_features);  // [batch, C]\n\n    // Broadcast back to spatial dimensions and combine with regular path\n    Tensor global_broadcast = broadcast_to_spatial(global_features);\n    x = regular_out + global_broadcast;\n  }\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"output-heads",children:"Output Heads"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Policy Head: Predict move probabilities\nclass PolicyHead {\n  // Output: 19\xd719+1 (including pass)\n  // Uses softmax normalization\n};\n\n// Value Head: Predict game outcome\nclass ValueHead {\n  // Output: 3 (win/loss/draw probabilities)\n  // Uses softmax normalization\n};\n\n// Score Head: Predict score\nclass ScoreHead {\n  // Output: continuous value (expected score difference)\n};\n\n// Ownership Head: Predict territory\nclass OwnershipHead {\n  // Output: 19\xd719 (ownership per point, tanh)\n};\n"})}),"\n",(0,o.jsx)(n.h2,{id:"search-engine-implementation",children:"Search Engine Implementation"}),"\n",(0,o.jsx)(n.h3,{id:"mcts-core-classes",children:"MCTS Core Classes"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// search/search.h\nclass Search {\npublic:\n  // Execute search\n  void runWholeSearch(Player pla);\n\n  // Get best move\n  Loc getBestMove();\n\n  // Get analysis results\n  AnalysisData getAnalysisData();\n\nprivate:\n  SearchParams params;          // Search parameters\n  SearchNode* rootNode;         // Root node\n  NNEvaluator* nnEval;         // Neural network evaluator\n  std::mutex* mutexPool;       // Lock pool\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"search-node-structure",children:"Search Node Structure"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// search/searchnode.h\nstruct SearchNode {\n  // Node statistics\n  std::atomic<int64_t> visits;           // Visit count\n  std::atomic<double> valueSumWeight;    // Value accumulation weight\n  std::atomic<double> valueSum;          // Value accumulation sum\n\n  // Child nodes\n  std::atomic<int> numChildren;\n  SearchChildPointer* children;          // Child node pointer array\n\n  // Neural network output cache\n  std::shared_ptr<NNOutput> nnOutput;\n};\n\nstruct SearchChildPointer {\n  Loc moveLoc;                           // Move location\n  std::atomic<SearchNode*> node;         // Child node pointer\n  std::atomic<int64_t> edgeVisits;       // Edge visit count\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"puct-selection-algorithm",children:"PUCT Selection Algorithm"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Select child node to explore\nint Search::selectChildToDescend(SearchNode* node, Player pla) {\n  int bestIdx = -1;\n  double bestValue = -1e100;\n\n  for (int i = 0; i < node->numChildren; i++) {\n    SearchChildPointer& child = node->children[i];\n\n    // Calculate Q value (exploitation)\n    double q = getChildQ(child);\n\n    // Calculate U value (exploration)\n    double prior = getPrior(node, child.moveLoc);\n    double parentVisits = node->visits.load();\n    double childVisits = child.edgeVisits.load();\n\n    double u = params.cpuctExploration * prior *\n               sqrt(parentVisits) / (1.0 + childVisits);\n\n    // PUCT formula\n    double value = q + u;\n\n    if (value > bestValue) {\n      bestValue = value;\n      bestIdx = i;\n    }\n  }\n\n  return bestIdx;\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"parallel-search-implementation",children:"Parallel Search Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"void Search::runWholeSearch(Player pla) {\n  // Start multiple search threads\n  std::vector<std::thread> threads;\n  for (int i = 0; i < params.numSearchThreads; i++) {\n    threads.emplace_back([this, pla]() {\n      runSingleSearchThread(pla);\n    });\n  }\n\n  // Wait for all threads to complete\n  for (auto& t : threads) {\n    t.join();\n  }\n}\n\nvoid Search::runSingleSearchThread(Player pla) {\n  while (!shouldStop()) {\n    // Select path\n    std::vector<SearchNode*> path;\n    SearchNode* leaf = selectAndDescend(rootNode, path);\n\n    // Expand node\n    expandNode(leaf);\n\n    // Neural network evaluation\n    NNOutput output = nnEval->evaluate(leaf->board);\n\n    // Backpropagate value\n    backpropagateValue(path, output.value);\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"virtual-loss",children:"Virtual Loss"}),"\n",(0,o.jsx)(n.p,{children:"Used in parallel search to prevent multiple threads from selecting the same path:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"void Search::applyVirtualLoss(SearchNode* node) {\n  // Temporarily reduce this node's evaluation value\n  // Makes other threads prefer different paths\n  node->virtualLoss.fetch_add(1);\n}\n\nvoid Search::removeVirtualLoss(SearchNode* node) {\n  node->virtualLoss.fetch_sub(1);\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"training-process-overview",children:"Training Process Overview"}),"\n",(0,o.jsx)(n.h3,{id:"training-data-generation",children:"Training Data Generation"}),"\n",(0,o.jsx)(n.mermaid,{value:'graph LR\n    subgraph TrainingLoop["Training Process Overview"]\n        SelfPlay["Self-play<br/>Worker"]\n        DataBuffer["Training Data<br/>Buffer"]\n        Trainer["Trainer<br/>(PyTorch)"]\n        NewModel["New Model"]\n\n        SelfPlay --\x3e DataBuffer\n        DataBuffer --\x3e Trainer\n        Trainer --\x3e NewModel\n        NewModel --\x3e SelfPlay\n    end'}),"\n",(0,o.jsx)(n.h3,{id:"self-play-cppcommandselfplaycpp",children:"Self-play (cpp/command/selfplay.cpp)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Self-play main loop\nvoid runSelfPlayLoop() {\n  while (true) {\n    // Load latest model\n    loadLatestModel();\n\n    // Play one game\n    GameData gameData = playSingleGame();\n\n    // Save training data\n    writeTrainingData(gameData);\n  }\n}\n\nGameData playSingleGame() {\n  Board board;\n  BoardHistory history;\n  GameData gameData;\n\n  while (!history.isGameOver()) {\n    // Use MCTS to select move\n    Search search(board, history, params);\n    search.runWholeSearch(history.currentPla);\n\n    // Get MCTS result as training target\n    MoveData moveData;\n    moveData.policyTarget = search.getPolicyDistribution();\n    moveData.valueTarget = search.getValue();\n\n    // Execute move\n    Loc move = search.sampleMove();\n    board.playMove(move, history.currentPla);\n\n    gameData.moves.push_back(moveData);\n  }\n\n  // Backfill final result\n  gameData.finalScore = history.finalScore();\n  return gameData;\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"training-data-format",children:"Training Data Format"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// dataio/trainingwrite.h\nstruct TrainingRow {\n  // Input features\n  float inputFeatures[NUM_FEATURES][BOARD_SIZE][BOARD_SIZE];\n\n  // Training targets\n  float policyTarget[BOARD_SIZE * BOARD_SIZE + 1];  // Including pass\n  float valueTarget[3];                              // Win/loss/draw\n  float scoreTarget;                                 // Score\n  float ownershipTarget[BOARD_SIZE][BOARD_SIZE];    // Territory\n\n  // Metadata\n  int turn;\n  int rules;\n  float komi;\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"python-training-program-pythontrainpy",children:"Python Training Program (python/train.py)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"# Training main loop (simplified)\ndef train():\n    model = KataGoModel(config)\n    optimizer = torch.optim.SGD(model.parameters(), lr=config.lr)\n\n    for epoch in range(config.num_epochs):\n        for batch in data_loader:\n            # Forward pass\n            policy_pred, value_pred, score_pred, ownership_pred = model(batch.input)\n\n            # Calculate losses\n            policy_loss = cross_entropy(policy_pred, batch.policy_target)\n            value_loss = cross_entropy(value_pred, batch.value_target)\n            score_loss = mse_loss(score_pred, batch.score_target)\n            ownership_loss = mse_loss(ownership_pred, batch.ownership_target)\n\n            # Total loss (weighted sum)\n            total_loss = (\n                policy_loss +\n                config.value_weight * value_loss +\n                config.score_weight * score_loss +\n                config.ownership_weight * ownership_loss\n            )\n\n            # Backpropagation\n            optimizer.zero_grad()\n            total_loss.backward()\n            optimizer.step()\n\n        # Save checkpoint\n        save_checkpoint(model, epoch)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"model-definition-pythonmodelpy",children:"Model Definition (python/model.py)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"class KataGoModel(nn.Module):\n    def __init__(self, config):\n        super().__init__()\n\n        # Initial convolution\n        self.initial_conv = nn.Conv2d(\n            config.input_channels,\n            config.trunk_channels,\n            kernel_size=3, padding=1\n        )\n\n        # Residual blocks\n        self.blocks = nn.ModuleList([\n            ResBlock(config.trunk_channels, use_global_pooling=True)\n            for _ in range(config.num_blocks)\n        ])\n\n        # Output heads\n        self.policy_head = PolicyHead(config)\n        self.value_head = ValueHead(config)\n        self.score_head = ScoreHead(config)\n        self.ownership_head = OwnershipHead(config)\n\n    def forward(self, x):\n        # Trunk network\n        x = self.initial_conv(x)\n        for block in self.blocks:\n            x = block(x)\n\n        # Output heads\n        policy = self.policy_head(x)\n        value = self.value_head(x)\n        score = self.score_head(x)\n        ownership = self.ownership_head(x)\n\n        return policy, value, score, ownership\n"})}),"\n",(0,o.jsx)(n.h2,{id:"key-data-structures",children:"Key Data Structures"}),"\n",(0,o.jsx)(n.h3,{id:"board-gameboardh",children:"Board (game/board.h)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"class Board {\npublic:\n  // Board state\n  Color stones[MAX_BOARD_AREA];    // Color at each point\n  Chain chains[MAX_BOARD_AREA];    // Chain information\n\n  // Ko\n  Loc koLoc;\n\n  // Execute move\n  void playMove(Loc loc, Color pla);\n\n  // Legality check\n  bool isLegal(Loc loc, Color pla) const;\n\n  // Liberty calculation\n  int getLiberties(Loc loc) const;\n};\n\nstruct Chain {\n  int liberties;                   // Liberty count\n  int numStones;                   // Stone count\n  Loc head;                        // Linked list head\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"boardhistory-gameboardhistoryh",children:"BoardHistory (game/boardhistory.h)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"class BoardHistory {\npublic:\n  std::vector<Board> boards;       // Historical board states\n  std::vector<Move> moves;         // Move history\n  Rules rules;                     // Rules\n  Player currentPla;               // Current player\n\n  // Game state\n  bool isGameOver() const;\n  float finalScore() const;\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"nnoutput-neuralnetnnevalh",children:"NNOutput (neuralnet/nneval.h)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"struct NNOutput {\n  // Policy\n  float policyProbs[MAX_BOARD_AREA + 1];  // Including pass\n\n  // Value\n  float whiteWinProb;\n  float whiteLossProb;\n  float noResultProb;\n\n  // Score\n  float whiteScoreMean;\n  float whiteScoreStdev;\n\n  // Ownership\n  float ownership[MAX_BOARD_AREA];  // -1 to 1\n};\n"})}),"\n",(0,o.jsx)(n.h2,{id:"development-and-debugging",children:"Development and Debugging"}),"\n",(0,o.jsx)(n.h3,{id:"build-debug-version",children:"Build Debug Version"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"cd cpp\nmkdir build_debug && cd build_debug\ncmake .. -DCMAKE_BUILD_TYPE=Debug -DUSE_BACKEND=OPENCL\nmake -j$(nproc)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"run-unit-tests",children:"Run Unit Tests"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"./katago runtests\n"})}),"\n",(0,o.jsx)(n.h3,{id:"common-debugging-methods",children:"Common Debugging Methods"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'// 1. Use logging\n#include "core/logger.h"\nLogger::log("Debug message", value);\n\n// 2. Use kata-debug-print GTP command\n// Outputs detailed search information\n\n// 3. Enable sanitizers at compile time\ncmake .. -DCMAKE_CXX_FLAGS="-fsanitize=address"\n'})}),"\n",(0,o.jsx)(n.h3,{id:"performance-analysis",children:"Performance Analysis"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'# Using perf (Linux)\nperf record ./katago benchmark -model model.bin.gz\nperf report\n\n# Using Instruments (macOS)\ninstruments -t "Time Profiler" ./katago benchmark -model model.bin.gz\n'})}),"\n",(0,o.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://github.com/lightvector/KataGo",children:"KataGo GitHub"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://arxiv.org/abs/1902.10565",children:"KataGo Paper"})}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"https://discord.gg/bqkZAz3",children:"KataGo Discord"})," - Communicate with developers"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"https://katagotraining.org/",children:"KataGo Training"})," - View training progress"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"After understanding KataGo's source code architecture, you now have the capability to deeply research or contribute to open source projects. For further exploration, we recommend directly reading KataGo's GitHub source code and participating in community discussions."})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},5521:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>s});var r=a(6672);const o={},t=r.createContext(o);function i(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);