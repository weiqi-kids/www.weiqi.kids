---
sidebar_position: 7
title: ë°”ë‘‘íŒ ìƒíƒœ í‘œí˜„
description: 2ì°¨ì› ë°°ì—´ë¶€í„° ì‹ ê²½ë§ íŠ¹ì§• í‰ë©´ê¹Œì§€, ë°”ë‘‘ AIê°€ ë°”ë‘‘íŒì„ ì–´ë–»ê²Œ 'ë³´ëŠ”ì§€' ì‹¬ì¸µ ì´í•´
keywords: [ë°”ë‘‘íŒí‘œí˜„, Zobrist Hashing, Union-Find, íŠ¹ì§•ì¸ì½”ë”©, AlphaGoíŠ¹ì§•í‰ë©´]
---

import { GoBoard } from '@site/src/components/D3Charts';

# ë°”ë‘‘íŒ ìƒíƒœ í‘œí˜„

ë°”ë‘‘ AIë¥¼ ì„¤ê³„í•˜ê¸° ì „ì—, ë¨¼ì € ê¸°ë³¸ì ì¸ ë¬¸ì œë¥¼ í•´ê²°í•´ì•¼ í•©ë‹ˆë‹¤: **ì»´í“¨í„°ê°€ ë°”ë‘‘íŒì„ ì–´ë–»ê²Œ 'ì´í•´'í•˜ê²Œ í•  ê²ƒì¸ê°€?**

ì´ ë¬¸ì œëŠ” ë‹¨ìˆœí•´ ë³´ì´ì§€ë§Œ, ìë£Œêµ¬ì¡°, ì•Œê³ ë¦¬ì¦˜, ê·¸ë¦¬ê³  ì‹ ê²½ë§ ì…ë ¥ ì„¤ê³„ ë“± ì—¬ëŸ¬ ì¸µë©´ì„ í¬í•¨í•©ë‹ˆë‹¤. ì´ ê¸€ì—ì„œëŠ” ê°€ì¥ ê¸°ë³¸ì ì¸ 2ì°¨ì› ë°°ì—´ë¶€í„° ì‹œì‘í•˜ì—¬, ë°”ë‘‘ AIê°€ ì‚¬ìš©í•˜ëŠ” ë‹¤ì–‘í•œ ë°”ë‘‘íŒ í‘œí˜„ ë°©ë²•ì„ ë‹¨ê³„ì ìœ¼ë¡œ ì†Œê°œí•˜ê³ , ìµœì¢…ì ìœ¼ë¡œ AlphaGoê°€ ë°”ë‘‘íŒì„ ì‹ ê²½ë§ì´ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” í˜•ì‹ìœ¼ë¡œ ì–´ë–»ê²Œ ì¸ì½”ë”©í•˜ëŠ”ì§€ ì„¤ëª…í•©ë‹ˆë‹¤.

---

## 2ì°¨ì› ë°°ì—´ í‘œí˜„: ê°€ì¥ ì§ê´€ì ì¸ ë°©ì‹

### ê¸°ë³¸ ê°œë…

ë°”ë‘‘íŒì€ 19Ã—19ì˜ ê²©ì ë„¤íŠ¸ì›Œí¬ë¡œ, ê°€ì¥ ì§ê´€ì ì¸ í‘œí˜„ ë°©ì‹ì€ **2ì°¨ì› ë°°ì—´**ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤:

```python
import numpy as np

# ë°”ë‘‘íŒ ìƒìˆ˜
BOARD_SIZE = 19
EMPTY = 0
BLACK = 1
WHITE = 2

# ë¹ˆ ë°”ë‘‘íŒ ì´ˆê¸°í™”
board = np.zeros((BOARD_SIZE, BOARD_SIZE), dtype=np.int8)

# ì°©ì : í‘ëŒ D4 (3, 3)
board[3, 3] = BLACK

# ì°©ì : ë°±ëŒ Q16 (15, 3)
board[15, 3] = WHITE
```

### ì¢Œí‘œ ì‹œìŠ¤í…œ

ë°”ë‘‘ì€ ë‘ ê°€ì§€ ì¼ë°˜ì ì¸ ì¢Œí‘œ ì‹œìŠ¤í…œì„ ì‚¬ìš©í•©ë‹ˆë‹¤:

#### 1. ìˆ«ì ì¢Œí‘œ (í”„ë¡œê·¸ë¨ìš©)

```
    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18
0   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
1   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
2   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
3   .  .  .  â—  .  .  .  .  .  +  .  .  .  .  .  â—‹  .  .  .
...
```

#### 2. ë¬¸ì-ìˆ«ì ì¢Œí‘œ (ê¸°ë³´ìš©)

```
    A  B  C  D  E  F  G  H  J  K  L  M  N  O  P  Q  R  S  T
19  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
18  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
17  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
16  .  .  .  â—  .  .  .  .  .  +  .  .  .  .  .  â—‹  .  .  .
...
```

ì°¸ê³ : ë¬¸ì ì¢Œí‘œëŠ” "I"ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤(ìˆ«ì 1ê³¼ì˜ í˜¼ë™ ë°©ì§€).

### ì¢Œí‘œ ë³€í™˜ í•¨ìˆ˜

```python
def coord_to_index(coord):
    """
    ê¸°ë³´ ì¢Œí‘œë¥¼ ë°°ì—´ ì¸ë±ìŠ¤ë¡œ ë³€í™˜
    ì˜ˆ: 'D4' -> (3, 15)
    """
    letters = 'ABCDEFGHJKLMNOPQRST'  # I ê±´ë„ˆëœ€
    col = letters.index(coord[0].upper())
    row = BOARD_SIZE - int(coord[1:])
    return row, col


def index_to_coord(row, col):
    """
    ë°°ì—´ ì¸ë±ìŠ¤ë¥¼ ê¸°ë³´ ì¢Œí‘œë¡œ ë³€í™˜
    ì˜ˆ: (3, 15) -> 'Q16'
    """
    letters = 'ABCDEFGHJKLMNOPQRST'
    return f"{letters[col]}{BOARD_SIZE - row}"
```

### ê³µê°„ ë³µì¡ë„ ë¶„ì„

2ì°¨ì› ë°°ì—´ í‘œí˜„ì˜ ê³µê°„ ë³µì¡ë„:

| í‘œí˜„ ë°©ì‹ | ê²©ìë‹¹ í¬ê¸° | ì´ ê³µê°„ |
|---------|---------|--------|
| `int8` | 1 byte | 361 bytes |
| `int32` | 4 bytes | 1.4 KB |
| `float64` | 8 bytes | 2.9 KB |

í˜„ëŒ€ ì»´í“¨í„°ì—ì„œ ì´ ì •ë„ ë©”ëª¨ë¦¬ëŠ” ì „í˜€ ë¬¸ì œê°€ ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ëŒ€ëŸ‰ì˜ ë°”ë‘‘íŒ ìƒíƒœë¥¼ ì €ì¥í•´ì•¼ í•  ë•Œ(ì˜ˆ: MCTS ê²€ìƒ‰ íŠ¸ë¦¬), `int8`ì„ ì‚¬ìš©í•˜ë©´ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ìƒë‹¹íˆ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ê¸°ë³¸ ì—°ì‚°

```python
class Board:
    def __init__(self, size=19):
        self.size = size
        self.board = np.zeros((size, size), dtype=np.int8)
        self.current_player = BLACK
        self.ko_point = None  # íŒ¨ ê¸ˆì§€ì 
        self.move_history = []

    def is_valid_move(self, row, col):
        """ì°©ì ì´ í•©ë²•ì ì¸ì§€ í™•ì¸"""
        # 1. ìœ„ì¹˜ê°€ ë°”ë‘‘íŒ ë‚´ì— ìˆìŒ
        if not (0 <= row < self.size and 0 <= col < self.size):
            return False

        # 2. ìœ„ì¹˜ê°€ ë¹„ì–´ìˆìŒ
        if self.board[row, col] != EMPTY:
            return False

        # 3. íŒ¨ ê¸ˆì§€ì ì´ ì•„ë‹˜
        if self.ko_point == (row, col):
            return False

        # 4. ìì‚´ì´ ì•„ë‹˜ (ë”°ë‚¼ ìˆ˜ ìˆëŠ” ê²½ìš° ì œì™¸)
        # ... ë” ë³µì¡í•œ ê²€ì‚¬ í•„ìš”

        return True

    def place_stone(self, row, col):
        """ì°©ì """
        if not self.is_valid_move(row, col):
            return False

        self.board[row, col] = self.current_player
        self.move_history.append((row, col))

        # ë”°ëƒ„ ì²˜ë¦¬
        captures = self._remove_captured_stones(row, col)

        # íŒ¨ ê¸ˆì§€ì  ì—…ë°ì´íŠ¸
        self._update_ko(row, col, captures)

        # í”Œë ˆì´ì–´ ì „í™˜
        self.current_player = WHITE if self.current_player == BLACK else BLACK

        return True
```

---

## Zobrist Hashing: ì¤‘ë³µ êµ­ë©´ì˜ ë¹ ë¥¸ ì‹ë³„

### ë¬¸ì œ ë°°ê²½

ë°”ë‘‘ AIì—ì„œëŠ” 'ë‘ êµ­ë©´ì´ ë™ì¼í•œì§€' ìì£¼ íŒë‹¨í•´ì•¼ í•©ë‹ˆë‹¤:

1. **íŒ¨ ê·œì¹™**: êµ­ë©´ì´ ì§ì „ ìƒíƒœë¡œ ëŒì•„ê°ˆ ìˆ˜ ì—†ìŒ
2. **ì‚¼íŒ¨**: íŠ¹ë³„ ê·œì¹™ ì²˜ë¦¬
3. **Transposition Table**: ì´ë¯¸ ê²€ìƒ‰í•œ êµ­ë©´ ê¸°ì–µ
4. **ì‹ ê²½ë§ ìºì‹œ**: ì¤‘ë³µ ê³„ì‚° ë°©ì§€

ë§¤ë²ˆ ê²©ìë³„ë¡œ ë¹„êµí•˜ë©´ O(361) ì‹œê°„ì´ í•„ìš”í•©ë‹ˆë‹¤. ë” ë¹ ë¥¸ ë°©ë²•ì´ ìˆì„ê¹Œìš”?

### Zobrist Hashing ì›ë¦¬

**Zobrist Hashing**(ë˜ëŠ” Zobrist Keys)ì€ Albert Zobristê°€ 1970ë…„ì— ì œì•ˆí•œ êµë¬˜í•œ í•´ì‹œ ë°©ë²•ì…ë‹ˆë‹¤. í•µì‹¬ ì•„ì´ë””ì–´ëŠ”:

1. ê° "ìœ„ì¹˜ Ã— ìƒ‰ìƒ" ì¡°í•©ì— ëŒ€í•´ **ë‚œìˆ˜**ë¥¼ ë¯¸ë¦¬ ìƒì„±
2. ë°”ë‘‘íŒì˜ í•´ì‹œê°’ = ëŒì´ ìˆëŠ” ëª¨ë“  ìœ„ì¹˜ì˜ ë‚œìˆ˜ë“¤ì˜ **XOR**
3. ì°©ì /ë”°ëƒ„ì€ í•œ ë²ˆì˜ XOR ì—°ì‚°ìœ¼ë¡œ í•´ì‹œê°’ ì—…ë°ì´íŠ¸ ê°€ëŠ¥

### ë‚œìˆ˜ í…Œì´ë¸”

```python
import numpy as np

# ë‚œìˆ˜ í…Œì´ë¸” ìƒì„±
# ì¬í˜„ì„±ì„ ìœ„í•´ ê³ ì • ì‹œë“œ ì‚¬ìš©
np.random.seed(42)

# ê° ìœ„ì¹˜, ê° ìƒ‰ìƒë§ˆë‹¤ í•˜ë‚˜ì˜ ë‚œìˆ˜
# zobrist[color][row][col]
zobrist_table = np.random.randint(
    0, 2**64,
    size=(3, BOARD_SIZE, BOARD_SIZE),  # 3: EMPTY, BLACK, WHITE
    dtype=np.uint64
)

# ëˆ„êµ¬ ì°¨ë¡€ì¸ì§€ë¥¼ ìœ„í•œ ë‚œìˆ˜
zobrist_player = np.random.randint(0, 2**64, dtype=np.uint64)
```

### XOR ì—°ì‚°ì˜ íŠ¹ì„±

XOR(ë°°íƒ€ì  ë…¼ë¦¬í•©) ì—°ì‚°ì€ ì´ ì‘ìš©ì— ë§¤ìš° ì í•©í•œ ëª‡ ê°€ì§€ ì¤‘ìš”í•œ íŠ¹ì„±ì„ ê°€ì§‘ë‹ˆë‹¤:

1. **ìê¸° ë°˜ì‚¬ì„±**: A âŠ• A = 0 (ê°™ì€ ìˆ˜ë¥¼ XORí•˜ë©´ 0)
2. **ê°€ì—­ì„±**: A âŠ• B âŠ• B = A (ë‘ ë²ˆ XORí•˜ë©´ ì›ë˜ëŒ€ë¡œ)
3. **êµí™˜ ë²•ì¹™**: A âŠ• B = B âŠ• A
4. **ê²°í•© ë²•ì¹™**: (A âŠ• B) âŠ• C = A âŠ• (B âŠ• C)

ì´ëŠ” ë‹¤ìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤:
- ì°©ì : `hash ^= zobrist[color][row][col]`
- ë”°ëƒ„: `hash ^= zobrist[color][row][col]` (ê°™ì€ ì—°ì‚°!)

### êµ¬í˜„

```python
class ZobristBoard:
    def __init__(self, size=19):
        self.size = size
        self.board = np.zeros((size, size), dtype=np.int8)
        self.current_player = BLACK
        self.hash = np.uint64(0)

        # ë‚œìˆ˜ í…Œì´ë¸” ì´ˆê¸°í™”
        self._init_zobrist_table()

    def _init_zobrist_table(self):
        np.random.seed(12345)
        self.zobrist = np.random.randint(
            0, 2**64,
            size=(3, self.size, self.size),
            dtype=np.uint64
        )
        self.zobrist_player = np.random.randint(0, 2**64, dtype=np.uint64)

    def place_stone(self, row, col, color):
        """ì°©ì  ë° í•´ì‹œê°’ ì—…ë°ì´íŠ¸"""
        # ì´ì „ ìƒíƒœ ì œê±° (ëŒì´ ìˆëŠ” ê²½ìš°)
        old_color = self.board[row, col]
        if old_color != EMPTY:
            self.hash ^= self.zobrist[old_color, row, col]

        # ìƒˆ ëŒ ì¶”ê°€
        self.board[row, col] = color
        self.hash ^= self.zobrist[color, row, col]

    def remove_stone(self, row, col):
        """ë”°ëƒ„ ë° í•´ì‹œê°’ ì—…ë°ì´íŠ¸"""
        color = self.board[row, col]
        if color != EMPTY:
            self.hash ^= self.zobrist[color, row, col]
            self.board[row, col] = EMPTY

    def switch_player(self):
        """í”Œë ˆì´ì–´ ì „í™˜ ë° í•´ì‹œê°’ ì—…ë°ì´íŠ¸"""
        self.hash ^= self.zobrist_player
        self.current_player = WHITE if self.current_player == BLACK else BLACK

    def get_hash(self):
        """í˜„ì¬ êµ­ë©´ì˜ í•´ì‹œê°’ ê°€ì ¸ì˜¤ê¸°"""
        return self.hash
```

### ì¦ë¶„ ì—…ë°ì´íŠ¸ì˜ ì¥ì 

Zobrist Hashingì„ ì‚¬ìš©í•˜ë©´ í•´ì‹œê°’ ì—…ë°ì´íŠ¸ì— O(1) ì‹œê°„ë§Œ í•„ìš”í•©ë‹ˆë‹¤:

| ì—°ì‚° | ì „í†µì  ë¹„êµ | Zobrist |
|------|---------|---------|
| ë‘ êµ­ë©´ ë¹„êµ | O(361) | O(1) |
| ì°©ì  í›„ ì—…ë°ì´íŠ¸ | O(361) | O(1) |
| ë”°ëƒ„ í›„ ì—…ë°ì´íŠ¸ | O(361) | O(k), këŠ” ë”°ë‚¸ ëŒ ìˆ˜ |

### ì¶©ëŒ í™•ë¥ 

64ë¹„íŠ¸ í•´ì‹œë¥¼ ì‚¬ìš©í•˜ë©´ ì¶©ëŒ í™•ë¥ ì´ ê·¹íˆ ë‚®ìŠµë‹ˆë‹¤:

**P(ì¶©ëŒ) â‰ˆ nÂ² / 2^65**

ì—¬ê¸°ì„œ nì€ ì„œë¡œ ë‹¤ë¥¸ êµ­ë©´ì˜ ìˆ˜ì…ë‹ˆë‹¤. 10ì–µ ê°œì˜ êµ­ë©´ì´ ìˆì–´ë„ ì¶©ëŒ í™•ë¥ ì€ ì•½ 10^-3ì— ë¶ˆê³¼í•©ë‹ˆë‹¤.

ì‹¤ì œë¡œ ë§ì€ ë°”ë‘‘ í”„ë¡œê·¸ë¨ì€ ì¶©ëŒ ê²€ì‚¬ ì—†ì´ 64ë¹„íŠ¸ Zobrist Hashingì„ ì‚¬ìš©í•˜ëŠ”ë°, ì¶©ëŒ í™•ë¥ ì´ ë¬´ì‹œí•´ë„ ë  ì •ë„ë¡œ ë‚®ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

---

## ëŒ ê·¸ë£¹ í‘œí˜„ (Union-Find): ì—°ê²°ì„± ë¬¸ì œ

### ëŒ ê·¸ë£¹ì˜ ê°œë…

ë°”ë‘‘ì—ì„œ **ëŒ ê·¸ë£¹**(String ë˜ëŠ” Chain)ì€ ì—°ê²°ëœ ê°™ì€ ìƒ‰ ëŒì˜ ì§‘í•©ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ëŒ ê·¸ë£¹ì˜ 'í™œë¡œ'ê°€ ìƒì‚¬ë¥¼ ê²°ì •í•©ë‹ˆë‹¤.

<GoBoard
  size={200}
  stones={[
    {x: 3, y: 3, color: 'black'},
    {x: 4, y: 3, color: 'black'},
    {x: 5, y: 3, color: 'black'},
    {x: 4, y: 4, color: 'black'},
    {x: 6, y: 3, color: 'white'},
    {x: 6, y: 4, color: 'white'},
  ]}
  labels={[
    {x: 4, y: 3, text: 'A'},
  ]}
/>

ìœ„ ê·¸ë¦¼ì—ì„œ ë„¤ ê°œì˜ í‘ëŒì´ í•˜ë‚˜ì˜ ëŒ ê·¸ë£¹ì„ í˜•ì„±í•˜ë©°, ì´ ëŒ ê·¸ë£¹ì˜ í™œë¡œ ìˆ˜ê°€ ìƒì‚¬ë¥¼ ê²°ì •í•©ë‹ˆë‹¤.

### ì™œ íš¨ìœ¨ì ì¸ ëŒ ê·¸ë£¹ ê´€ë¦¬ê°€ í•„ìš”í•œê°€?

ë§¤ ì°©ì ë§ˆë‹¤ ë‹¤ìŒì´ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:
1. ìƒˆ ëŒ ê·¸ë£¹ **ìƒì„±**
2. ì—¬ëŸ¬ ëŒ ê·¸ë£¹ **ë³‘í•©**
3. ìƒëŒ€ ëŒ ê·¸ë£¹ì˜ í™œë¡œ **ê°ì†Œ**
4. í™œë¡œê°€ ì—†ëŠ” ëŒ ê·¸ë£¹ **ë”°ëƒ„**

ì´ëŸ¬í•œ ì—°ì‚°ì€ íš¨ìœ¨ì ìœ¼ë¡œ ìˆ˜í–‰ë˜ì–´ì•¼ í•©ë‹ˆë‹¤. MCTSì—ì„œëŠ” 1ì´ˆì— ìˆ˜ë§Œ ë²ˆì˜ ì°©ì  ì‹œë®¬ë ˆì´ì…˜ì´ í•„ìš”í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

### Union-Find ìë£Œêµ¬ì¡°

**Union-Find**(ë˜ëŠ” Disjoint Set Union, DSU)ëŠ” 'ì—°ê²°ì„±' ë¬¸ì œë¥¼ ì²˜ë¦¬í•˜ëŠ” ê³ ì „ì ì¸ ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤:

```python
class UnionFind:
    def __init__(self, size):
        # parent[i]ëŠ” iì˜ ë¶€ëª¨ ë…¸ë“œë¥¼ ê°€ë¦¬í‚´
        # parent[i] = iì´ë©´ iê°€ ë£¨íŠ¸ ë…¸ë“œ
        self.parent = list(range(size))
        self.rank = [0] * size

    def find(self, x):
        """
        xê°€ ì†í•œ ì§‘í•©ì˜ ë£¨íŠ¸ ë…¸ë“œ ì°¾ê¸° (ê²½ë¡œ ì••ì¶• í¬í•¨)
        """
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # ê²½ë¡œ ì••ì¶•
        return self.parent[x]

    def union(self, x, y):
        """
        xì™€ yê°€ ì†í•œ ì§‘í•© ë³‘í•© (ë­í¬ ê¸°ë°˜ ë³‘í•© í¬í•¨)
        """
        root_x = self.find(x)
        root_y = self.find(y)

        if root_x == root_y:
            return  # ì´ë¯¸ ê°™ì€ ì§‘í•©

        # ë­í¬ ê¸°ë°˜ ë³‘í•©: ì‘ì€ íŠ¸ë¦¬ë¥¼ í° íŠ¸ë¦¬ì— ì—°ê²°
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1
```

### ì‹œê°„ ë³µì¡ë„

Union-Findì˜ ì‹œê°„ ë³µì¡ë„ëŠ” **ì—­ ì•„ì»¤ë§Œ í•¨ìˆ˜** Î±(n)ìœ¼ë¡œ í‘œí˜„ë©ë‹ˆë‹¤:

| ì—°ì‚° | ì‹œê°„ ë³µì¡ë„ |
|------|-----------|
| find | O(Î±(n)) â‰ˆ O(1) |
| union | O(Î±(n)) â‰ˆ O(1) |

Î±(n)ì€ ë§¤ìš° ëŠë¦¬ê²Œ ì¦ê°€í•˜ì—¬, ì‹¤ì œ ì–´ë–¤ nì— ëŒ€í•´ì„œë„ Î±(n) â‰¤ 4ì…ë‹ˆë‹¤. ë”°ë¼ì„œ ìƒìˆ˜ ì‹œê°„ìœ¼ë¡œ ê°„ì£¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ë°”ë‘‘ì—ì„œì˜ Union-Find ì ìš©

```python
class GoStringManager:
    def __init__(self, size=19):
        self.size = size
        num_points = size * size

        # Union-Find êµ¬ì¡°
        self.parent = list(range(num_points))
        self.rank = [0] * num_points

        # ê° ëŒ ê·¸ë£¹ì˜ í™œë¡œ (ë£¨íŠ¸ ë…¸ë“œ ì¸ë±ìŠ¤ ì‚¬ìš©)
        self.liberties = [set() for _ in range(num_points)]

        # ê° ëŒ ê·¸ë£¹ì˜ ëŒë“¤ (ë£¨íŠ¸ ë…¸ë“œ ì¸ë±ìŠ¤ ì‚¬ìš©)
        self.stones = [set() for _ in range(num_points)]

    def _index(self, row, col):
        return row * self.size + col

    def _neighbors(self, row, col):
        """4ë°©í–¥ ì´ì›ƒ ê°€ì ¸ì˜¤ê¸°"""
        neighbors = []
        if row > 0: neighbors.append((row - 1, col))
        if row < self.size - 1: neighbors.append((row + 1, col))
        if col > 0: neighbors.append((row, col - 1))
        if col < self.size - 1: neighbors.append((row, col + 1))
        return neighbors

    def find(self, idx):
        if self.parent[idx] != idx:
            self.parent[idx] = self.find(self.parent[idx])
        return self.parent[idx]

    def add_stone(self, row, col, color, board):
        """
        ëŒ ì¶”ê°€, ì—°ê²° ë° ë”°ëƒ„ ì²˜ë¦¬
        """
        idx = self._index(row, col)

        # ìƒˆ ëŒ ê·¸ë£¹ ìƒì„±
        self.stones[idx] = {idx}
        self.liberties[idx] = set()

        # ì´ ëŒì˜ í™œë¡œ ê³„ì‚°
        for nr, nc in self._neighbors(row, col):
            nidx = self._index(nr, nc)
            if board[nr, nc] == 0:  # ë¹ˆ ì ì´ í™œë¡œ
                self.liberties[idx].add(nidx)

        # ê°™ì€ ìƒ‰ ì´ì›ƒê³¼ ë³‘í•©
        for nr, nc in self._neighbors(row, col):
            nidx = self._index(nr, nc)
            if board[nr, nc] == color:
                self._merge_strings(idx, nidx)

        # ìƒëŒ€ ëŒ ê·¸ë£¹ì˜ í™œë¡œ ê°ì†Œ
        opponent = 3 - color  # BLACK=1, WHITE=2
        captured = []
        for nr, nc in self._neighbors(row, col):
            nidx = self._index(nr, nc)
            if board[nr, nc] == opponent:
                root = self.find(nidx)
                self.liberties[root].discard(idx)
                if len(self.liberties[root]) == 0:
                    captured.append(root)

        return captured

    def _merge_strings(self, idx1, idx2):
        """ë‘ ëŒ ê·¸ë£¹ ë³‘í•©"""
        root1 = self.find(idx1)
        root2 = self.find(idx2)

        if root1 == root2:
            return

        # ë­í¬ ê¸°ë°˜ ë³‘í•©
        if self.rank[root1] < self.rank[root2]:
            root1, root2 = root2, root1

        self.parent[root2] = root1
        if self.rank[root1] == self.rank[root2]:
            self.rank[root1] += 1

        # í™œë¡œì™€ ëŒ ì§‘í•© ë³‘í•©
        self.liberties[root1] |= self.liberties[root2]
        self.stones[root1] |= self.stones[root2]

        # ìì‹ ì˜ ìœ„ì¹˜ë¥¼ í™œë¡œì—ì„œ ì œê±° (ìì‹ ì€ ìì‹ ì˜ í™œë¡œê°€ ì•„ë‹˜)
        for stone_idx in self.stones[root2]:
            self.liberties[root1].discard(stone_idx)
```

### í™œë¡œ ê³„ì‚°

ëŒ ê·¸ë£¹ì˜ í™œë¡œ ìˆ˜ ê³„ì‚°ì€ ë°”ë‘‘ì—ì„œ ê°€ì¥ í”í•œ ì—°ì‚° ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤:

```python
def count_liberties(self, row, col, board):
    """íŠ¹ì • ëŒì´ ì†í•œ ëŒ ê·¸ë£¹ì˜ í™œë¡œ ìˆ˜ ê³„ì‚°"""
    idx = self._index(row, col)
    root = self.find(idx)
    return len(self.liberties[root])
```

Union-Findë¥¼ ì‚¬ìš©í•˜ë©´ ì´ ì—°ì‚°ì€ O(1)ì…ë‹ˆë‹¤(findê°€ O(1)ì´ë¼ê³  ê°€ì •).

---

## íŠ¹ì§• ì¸ì½”ë”©ì˜ ì§„í™”

ì „í†µì ì¸ ìˆ˜ì‘ì—… íŠ¹ì§•ì—ì„œ AlphaGo Zeroì˜ ê°„ê²°í•œ íŠ¹ì§•ê¹Œì§€, ë°”ë‘‘ AIì˜ íŠ¹ì§• ì¸ì½”ë”©ì€ ì¤‘ëŒ€í•œ ì§„í™”ë¥¼ ê²ªì—ˆìŠµë‹ˆë‹¤.

### GNU Goì˜ ìˆ˜ì‘ì—… íŠ¹ì§•

ì´ˆê¸° ë°”ë‘‘ í”„ë¡œê·¸ë¨(ì˜ˆ: GNU Go)ì€ ëŒ€ëŸ‰ì˜ ìˆ˜ì‘ì—…ìœ¼ë¡œ ì„¤ê³„ëœ íŠ¹ì§•ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤:

```python
def extract_features_gnugo(board, point):
    """
    GNU Go ìŠ¤íƒ€ì¼ì˜ ìˆ˜ì‘ì—… íŠ¹ì§• ì¶”ì¶œ
    """
    features = {}

    # 1. ëª¨ì–‘ íŒ¨í„´ (ë¯¸ë¦¬ ì •ì˜ëœ ì§€ì—­ í˜•íƒœ)
    features['pattern'] = match_pattern(board, point)

    # 2. ì „ìˆ  íŠ¹ì§•
    features['can_capture'] = check_capture(board, point)
    features['can_connect'] = check_connect(board, point)
    features['creates_eye'] = check_eye_creation(board, point)

    # 3. ì§€ì—­ íŠ¹ì§•
    features['liberties_after'] = count_liberties_after_move(board, point)
    features['enemy_liberties'] = count_enemy_liberties(board, point)

    # 4. ì „ì—­ íŠ¹ì§•
    features['distance_to_edge'] = min(
        point[0], point[1],
        18 - point[0], 18 - point[1]
    )

    # ... ë” ë§ì€ íŠ¹ì§•

    return features
```

ì´ ë°©ë²•ì˜ ë¬¸ì œì :
- ëŒ€ëŸ‰ì˜ ì¸ê°„ ì „ë¬¸ê°€ ì§€ì‹ í•„ìš”
- íŠ¹ì§•ì´ ë¶ˆì™„ì „í•  ìˆ˜ ìˆìŒ
- ìƒˆë¡œìš´ íŒ¨í„´ì„ ë°œê²¬í•˜ê¸° ì–´ë ¤ì›€

### AlphaGoì˜ 48ê°œ íŠ¹ì§• í‰ë©´

AlphaGo(2016 Nature ë²„ì „)ëŠ” ì‹ ê²½ë§ ì…ë ¥ìœ¼ë¡œ **48ê°œ íŠ¹ì§• í‰ë©´**ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤:

```python
def encode_alphago_features(board, player, history):
    """
    AlphaGo 2016ì˜ 48ê°œ íŠ¹ì§• í‰ë©´

    Returns:
        (19, 19, 48) í…ì„œ
    """
    features = np.zeros((19, 19, 48), dtype=np.float32)

    # í‰ë©´ 1: í‘ëŒ ìœ„ì¹˜
    features[:, :, 0] = (board == BLACK)

    # í‰ë©´ 2: ë°±ëŒ ìœ„ì¹˜
    features[:, :, 1] = (board == WHITE)

    # í‰ë©´ 3: ë¹ˆ ì 
    features[:, :, 2] = (board == EMPTY)

    # í‰ë©´ 4: ì „ì²´ 1 (ë°”ì´ì–´ìŠ¤ í•­)
    features[:, :, 3] = 1

    # í‰ë©´ 5-12: í™œë¡œ ìˆ˜ ì¸ì½”ë”© (1-8 í™œë¡œ ê°ê° í•˜ë‚˜ì˜ í‰ë©´)
    for i, num_libs in enumerate(range(1, 9)):
        for r in range(19):
            for c in range(19):
                if board[r, c] != EMPTY:
                    libs = count_liberties(board, r, c)
                    if libs == num_libs:
                        features[r, c, 4 + i] = 1

    # í‰ë©´ 13-20: ë”°ë‚¸ í›„ ìƒëŒ€ í™œë¡œ ìˆ˜
    # ...

    # í‰ë©´ 21-28: ì°©ì  í›„ ìì‹ ì˜ í™œë¡œ ìˆ˜
    # ...

    # í‰ë©´ 29-36: ê³¼ê±° 8ìˆ˜ì˜ ê¸°ë¡ (ê° ìˆ˜ë§ˆë‹¤ í•˜ë‚˜ì˜ í‰ë©´)
    for i, (r, c) in enumerate(history[-8:]):
        features[r, c, 28 + i] = 1

    # í‰ë©´ 37-44: ì¶•ë¨¸ë¦¬ íŒë‹¨
    # ...

    # í‰ë©´ 45-48: ëŒ€ì¹­ì„± ê´€ë ¨
    # ...

    # í‰ë©´ 49: ëˆ„êµ¬ ì°¨ë¡€ì¸ì§€ (ì „ì²´ 1ì€ í‘, ì „ì²´ 0ì€ ë°±)
    if player == BLACK:
        features[:, :, 47] = 1

    return features
```

### 48ê°œ í‰ë©´ì˜ ë¶„ë¥˜

| ì¹´í…Œê³ ë¦¬ | í‰ë©´ ìˆ˜ | ì„¤ëª… |
|------|--------|------|
| ëŒ ìœ„ì¹˜ | 3 | í‘ëŒ, ë°±ëŒ, ë¹ˆ ì  |
| ìƒìˆ˜ | 1 | ì „ì²´ 1 |
| í™œë¡œ ìˆ˜ | 8 | 1-8 í™œë¡œ |
| ë”°ë‚¸ í›„ í™œë¡œ ìˆ˜ | 8 | ì°©ì  í›„ ê°€ì • í™œë¡œ ìˆ˜ |
| ì°©ì  í›„ í™œë¡œ ìˆ˜ | 8 | ì°©ì  í›„ ê°€ì • í™œë¡œ ìˆ˜ |
| ê¸°ë¡ | 8 | ê³¼ê±° 8ìˆ˜ |
| ì¶•ë¨¸ë¦¬ | 8 | ë³µì¡í•œ ì¶•ë¨¸ë¦¬ ë¶„ì„ |
| ê¸°íƒ€ | 4 | ì°¨ë¡€, ëŒ€ì¹­ì„± ë“± |

### AlphaGo Zeroì˜ 17ê°œ íŠ¹ì§• í‰ë©´

AlphaGo Zero(2017)ëŠ” íŠ¹ì§• ì¸ì½”ë”©ì„ ëŒ€í­ ê°„ì†Œí™”í•˜ì—¬, **17ê°œ í‰ë©´**ë§Œ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤:

```python
def encode_alphago_zero_features(board_history, player):
    """
    AlphaGo Zeroì˜ 17ê°œ íŠ¹ì§• í‰ë©´

    Args:
        board_history: ê³¼ê±° 8ê°œ êµ­ë©´ (í˜„ì¬ í¬í•¨)
        player: í˜„ì¬ í”Œë ˆì´ì–´

    Returns:
        (19, 19, 17) í…ì„œ
    """
    features = np.zeros((19, 19, 17), dtype=np.float32)

    # í‰ë©´ 1-8: í‘ëŒ ê¸°ë¡ (ìµœê·¼ 8ìˆ˜)
    for i, board in enumerate(board_history[-8:]):
        features[:, :, i] = (board == BLACK)

    # í‰ë©´ 9-16: ë°±ëŒ ê¸°ë¡ (ìµœê·¼ 8ìˆ˜)
    for i, board in enumerate(board_history[-8:]):
        features[:, :, 8 + i] = (board == WHITE)

    # í‰ë©´ 17: ëˆ„êµ¬ ì°¨ë¡€ì¸ì§€ (ì „ì²´ 1ì€ í‘, ì „ì²´ 0ì€ ë°±)
    if player == BLACK:
        features[:, :, 16] = 1

    return features
```

### 17ê°œ í‰ë©´ì˜ ê°„ê²°í•¨

| ì¹´í…Œê³ ë¦¬ | í‰ë©´ ìˆ˜ | ì„¤ëª… |
|------|--------|------|
| í‘ëŒ ê¸°ë¡ | 8 | ê³¼ê±° 8ê°œ íƒ€ì„ìŠ¤í…ì˜ í‘ëŒ ìœ„ì¹˜ |
| ë°±ëŒ ê¸°ë¡ | 8 | ê³¼ê±° 8ê°œ íƒ€ì„ìŠ¤í…ì˜ ë°±ëŒ ìœ„ì¹˜ |
| í˜„ì¬ í”Œë ˆì´ì–´ | 1 | ì „ì²´ 1 ë˜ëŠ” ì „ì²´ 0 |

ì™œ ì´ë ‡ê²Œ ê°„ê²°í•  ìˆ˜ ìˆì„ê¹Œìš”?

> **í•µì‹¬ í†µì°°: ì‹ ê²½ë§ì´ ìŠ¤ìŠ¤ë¡œ íŠ¹ì§•ì„ í•™ìŠµí•˜ê²Œ í•©ë‹ˆë‹¤.**

AlphaGo ZeroëŠ” ë‹¤ìŒì„ ì¦ëª…í–ˆìŠµë‹ˆë‹¤:
- í™œë¡œ ìˆ˜ë¥¼ ìˆ˜ì‘ì—…ìœ¼ë¡œ ê³„ì‚°í•  í•„ìš” ì—†ìŒ (ë„¤íŠ¸ì›Œí¬ê°€ ëŒ ìœ„ì¹˜ì—ì„œ ì¶”ë¡  ê°€ëŠ¥)
- ì¶•ë¨¸ë¦¬ ë¶„ì„ì´ í•„ìš” ì—†ìŒ (ë„¤íŠ¸ì›Œí¬ê°€ ì¶•ë¨¸ë¦¬ ì¸ì‹ í•™ìŠµ ê°€ëŠ¥)
- ë³µì¡í•œ ë”°ëƒ„ ì˜ˆì¸¡ì´ í•„ìš” ì—†ìŒ (ë„¤íŠ¸ì›Œí¬ê°€ ì°©ì  ê²°ê³¼ ì´í•´ ê°€ëŠ¥)

ì´ëŠ” ë”¥ëŸ¬ë‹ì˜ í•µì‹¬ ì¥ì ì„ ë³´ì—¬ì¤ë‹ˆë‹¤: **ì¢…ë‹¨ê°„ í•™ìŠµ**.

### íŠ¹ì§• í‰ë©´ì˜ ì‹œê°í™”

ì´ëŸ¬í•œ íŠ¹ì§• í‰ë©´ì´ ì‹¤ì œë¡œ ì–´ë–»ê²Œ ìƒê²¼ëŠ”ì§€ ì‚´í´ë´…ì‹œë‹¤:

```
ì›ë³¸ ë°”ë‘‘íŒ:              í‘ëŒ í‰ë©´:              ë°±ëŒ í‰ë©´:
. . . . . .            0 0 0 0 0 0            0 0 0 0 0 0
. â— â—‹ . . .            0 1 0 0 0 0            0 0 1 0 0 0
. . â— â—‹ . .    ->      0 0 1 0 0 0     +      0 0 0 1 0 0
. . . â— . .            0 0 0 1 0 0            0 0 0 0 0 0
. . . . . .            0 0 0 0 0 0            0 0 0 0 0 0
```

ê° í‰ë©´ì€ ì´ì§„ í–‰ë ¬(0 ë˜ëŠ” 1)ì´ë©°, ì‹ ê²½ë§ì€ ì»¨ë³¼ë£¨ì…˜ ì—°ì‚°ì„ í†µí•´ ì´ëŸ¬í•œ í‰ë©´ì˜ íŒ¨í„´ì„ ì¶”ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

## ëŒ€ì¹­ì„± ì²˜ë¦¬: 8ê°€ì§€ ë³€í™˜

### ë°”ë‘‘ì˜ ëŒ€ì¹­ì„±

ë°”ë‘‘íŒì€ **8ê°€ì§€ ëŒ€ì¹­ì„±**ì„ ê°€ì§‘ë‹ˆë‹¤:

1. **4ê°€ì§€ íšŒì „**: 0Â°, 90Â°, 180Â°, 270Â°
2. **4ê°€ì§€ ë’¤ì§‘ê¸° í›„ íšŒì „**: ìˆ˜í‰ ë’¤ì§‘ê¸° + 4ê°€ì§€ íšŒì „

ì´ê²ƒì€ **ì´ë©´ì²´ êµ° D4**ë¥¼ í˜•ì„±í•©ë‹ˆë‹¤.

### ìˆ˜í•™ì  í‘œí˜„

(x, y)ë¥¼ ë°”ë‘‘íŒì˜ ì¢Œí‘œ(ì¤‘ì‹¬ì€ (9, 9))ë¼ í•˜ë©´, 8ê°€ì§€ ë³€í™˜ì€ ë‹¤ìŒê³¼ ê°™ì´ í‘œí˜„ë©ë‹ˆë‹¤:

| ë³€í™˜ | ê³µì‹ |
|------|------|
| í•­ë“± | (x, y) |
| 90Â° íšŒì „ | (-y, x) |
| 180Â° íšŒì „ | (-x, -y) |
| 270Â° íšŒì „ | (y, -x) |
| ìˆ˜í‰ ë’¤ì§‘ê¸° | (-x, y) |
| ìˆ˜ì§ ë’¤ì§‘ê¸° | (x, -y) |
| ëŒ€ê° ë’¤ì§‘ê¸° | (y, x) |
| ë°˜ëŒ€ê° ë’¤ì§‘ê¸° | (-y, -x) |

### í”„ë¡œê·¸ë¨ êµ¬í˜„

```python
def get_symmetries(board):
    """
    ë°”ë‘‘íŒì˜ 8ê°€ì§€ ëŒ€ì¹­ ë³€í™˜ ê°€ì ¸ì˜¤ê¸°

    Returns:
        8ê°œ ë°”ë‘‘íŒì˜ ë¦¬ìŠ¤íŠ¸
    """
    symmetries = []

    # ì›ë³¸
    symmetries.append(board.copy())

    # 90Â° íšŒì „
    symmetries.append(np.rot90(board, k=1))

    # 180Â° íšŒì „
    symmetries.append(np.rot90(board, k=2))

    # 270Â° íšŒì „
    symmetries.append(np.rot90(board, k=3))

    # ìˆ˜í‰ ë’¤ì§‘ê¸°
    symmetries.append(np.fliplr(board))

    # ìˆ˜ì§ ë’¤ì§‘ê¸°
    symmetries.append(np.flipud(board))

    # ëŒ€ê° ë’¤ì§‘ê¸°
    symmetries.append(board.T)

    # ë°˜ëŒ€ê° ë’¤ì§‘ê¸°
    symmetries.append(np.rot90(board.T, k=2))

    return symmetries


def apply_symmetry(board, sym_index):
    """
    sym_indexë²ˆì§¸ ëŒ€ì¹­ ë³€í™˜ ì ìš©
    """
    return get_symmetries(board)[sym_index]


def inverse_symmetry(move, sym_index, board_size=19):
    """
    ë³€í™˜ëœ ì°©ì  ì¢Œí‘œë¥¼ ì›ë˜ ì¢Œí‘œë¡œ ë³€í™˜
    """
    row, col = move

    if sym_index == 0:  # í•­ë“±
        return row, col
    elif sym_index == 1:  # 90Â° íšŒì „
        return col, board_size - 1 - row
    elif sym_index == 2:  # 180Â° íšŒì „
        return board_size - 1 - row, board_size - 1 - col
    elif sym_index == 3:  # 270Â° íšŒì „
        return board_size - 1 - col, row
    elif sym_index == 4:  # ìˆ˜í‰ ë’¤ì§‘ê¸°
        return row, board_size - 1 - col
    elif sym_index == 5:  # ìˆ˜ì§ ë’¤ì§‘ê¸°
        return board_size - 1 - row, col
    elif sym_index == 6:  # ëŒ€ê° ë’¤ì§‘ê¸°
        return col, row
    elif sym_index == 7:  # ë°˜ëŒ€ê° ë’¤ì§‘ê¸°
        return board_size - 1 - col, board_size - 1 - row
```

### ë°ì´í„° ì¦ê°•

ì‹ ê²½ë§ í•™ìŠµ ì‹œ, ëŒ€ì¹­ì„±ì„ í™œìš©í•˜ì—¬ **ë°ì´í„° ì¦ê°•**ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```python
def augment_training_data(board, policy, value):
    """
    í•˜ë‚˜ì˜ í•™ìŠµ ìƒ˜í”Œì„ 8ê°œë¡œ í™•ì¥
    """
    augmented = []

    for sym_index in range(8):
        # ë°”ë‘‘íŒ ë³€í™˜
        aug_board = apply_symmetry(board, sym_index)

        # ì •ì±… ë³€í™˜ (361ì°¨ì› ë²¡í„°)
        policy_2d = policy.reshape(19, 19)
        aug_policy_2d = apply_symmetry(policy_2d, sym_index)
        aug_policy = aug_policy_2d.flatten()

        # ê°€ì¹˜ëŠ” ë³€í•˜ì§€ ì•ŠìŒ
        aug_value = value

        augmented.append((aug_board, aug_policy, aug_value))

    return augmented
```

ì´ë¥¼ í†µí•´ í•™ìŠµ ë°ì´í„°ëŸ‰ì´ 8ë°° ì¦ê°€í•˜ë©°, ì™„ì „íˆ ë¬´ë£Œì…ë‹ˆë‹¤(ìƒˆ ë°ì´í„°ë¥¼ ìˆ˜ì§‘í•  í•„ìš” ì—†ìŒ).

### ì¶”ë¡  ì‹œ ëŒ€ì¹­ì„± í™œìš©

AlphaGoëŠ” ì‹¤ì œ ëŒ€êµ­ì—ì„œë„ ëŒ€ì¹­ì„±ì„ í™œìš©í•©ë‹ˆë‹¤:

```python
def predict_with_symmetry(model, board):
    """
    ëŒ€ì¹­ì„±ì„ í™œìš©í•œ í–¥ìƒëœ ì˜ˆì¸¡
    """
    policies = []
    values = []

    for sym_index in range(8):
        # ì…ë ¥ ë³€í™˜
        aug_board = apply_symmetry(board, sym_index)

        # ì‹ ê²½ë§ ì˜ˆì¸¡
        policy, value = model.predict(aug_board)

        # ì •ì±…ì„ ì›ë˜ ì¢Œí‘œê³„ë¡œ ë³€í™˜
        policy_2d = policy.reshape(19, 19)
        original_policy = inverse_symmetry_2d(policy_2d, sym_index)
        policies.append(original_policy.flatten())

        values.append(value)

    # ëª¨ë“  ì˜ˆì¸¡ì˜ í‰ê· 
    avg_policy = np.mean(policies, axis=0)
    avg_value = np.mean(values)

    return avg_policy, avg_value
```

ì´ ë°©ë²•ì€ ì˜ˆì¸¡ì˜ ì •í™•ë„ì™€ ì•ˆì •ì„±ì„ ì•½ê°„ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

## ë°”ë‘‘íŒ í‘œí˜„ ë°©ë²• ìš”ì•½

| ë°©ë²• | ìš©ë„ | ë³µì¡ë„ | íŠ¹ì§• |
|------|------|--------|------|
| **2ì°¨ì› ë°°ì—´** | ê¸°ë³¸ ì €ì¥ | O(361) ê³µê°„ | ë‹¨ìˆœ ì§ê´€ì  |
| **Zobrist Hashing** | êµ­ë©´ ì‹ë³„ | O(1) ì¡°íšŒ | ê³ íš¨ìœ¨ í•´ì‹œ |
| **Union-Find** | ëŒ ê·¸ë£¹ ê´€ë¦¬ | O(Î±(n)) ì—°ì‚° | ì—°ê²°ì„± ì²˜ë¦¬ |
| **íŠ¹ì§• í‰ë©´** | ì‹ ê²½ë§ ì…ë ¥ | O(361Ã—í‰ë©´ ìˆ˜) | í’ë¶€í•œ ì •ë³´ ì¸ì½”ë”© |
| **ëŒ€ì¹­ì„± ë³€í™˜** | ë°ì´í„° ì¦ê°• | 8Ã— ë°ì´í„°ëŸ‰ | ë¬´ë£Œ í™•ì¥ |

ì´ëŸ¬í•œ ê¸°ìˆ ë“¤ì´ ìƒí˜¸ í˜‘ë ¥í•˜ì—¬ í˜„ëŒ€ ë°”ë‘‘ AIì˜ ê¸°ë°˜ ì¸í”„ë¼ë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤.

---

## ì• ë‹ˆë©”ì´ì…˜ ëŒ€ì‘

ì´ ê¸€ì—ì„œ ë‹¤ë£¨ëŠ” í•µì‹¬ ê°œë…ê³¼ ì• ë‹ˆë©”ì´ì…˜ ë²ˆí˜¸:

| ë²ˆí˜¸ | ê°œë… | ë¬¼ë¦¬/ìˆ˜í•™ ëŒ€ì‘ |
|------|------|--------------|
| ğŸ¬ A1 | 2ì°¨ì› ë°°ì—´ í‘œí˜„ | í–‰ë ¬, í¬ì†Œ ë°ì´í„° |
| ğŸ¬ A2 | Zobrist Hashing | í•´ì‹œ í•¨ìˆ˜, XOR ì—°ì‚° |
| ğŸ¬ A8 | íŠ¹ì§• í‰ë©´ ì¸ì½”ë”© | í…ì„œ, ë‹¤ì±„ë„ ì…ë ¥ |
| ğŸ¬ A5 | ëŒ€ì¹­ì„± ì²˜ë¦¬ | êµ°ë¡ , ì´ë©´ì²´ êµ° |

---

## ì¶”ê°€ ì½ê¸°

- **ì´ì „ ê¸€**: [ì „í†µì  ë°©ë²•ì˜ í•œê³„](../traditional-limits) â€” Minimaxì—ì„œ MCTSê¹Œì§€
- **ë‹¤ìŒ ê¸€**: [Policy Network ìƒì„¸ ì„¤ëª…](../policy-network) â€” ì‹ ê²½ë§ì´ ì°©ì ì„ ì–´ë–»ê²Œ ì˜ˆì¸¡í•˜ëŠ”ê°€
- **ì‹¤ìŠµ**: [30ë¶„ ë§Œì— ì²« ë°”ë‘‘ AI ì‹¤í–‰í•˜ê¸°](../../../hands-on/) â€” ì§ì ‘ ì²´í—˜í•´ë³´ê¸°

---

## ì°¸ê³  ìë£Œ

1. Zobrist, A. L. (1970). "A new hashing method with application for game playing." ICCA journal.
2. Tarjan, R. E. (1975). "Efficiency of a Good But Not Linear Set Union Algorithm." Journal of the ACM, 22(2), 215-225.
3. Silver, D., et al. (2016). "Mastering the game of Go with deep neural networks and tree search." Nature, 529, 484-489. â€” AlphaGo 48ê°œ íŠ¹ì§• í‰ë©´
4. Silver, D., et al. (2017). "Mastering the game of Go without human knowledge." Nature, 550, 354-359. â€” AlphaGo Zero 17ê°œ íŠ¹ì§• í‰ë©´
