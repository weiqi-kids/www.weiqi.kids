---
sidebar_position: 7
title: æ£‹ç›¤ç‹€æ…‹è¡¨ç¤º
description: å¾äºŒç¶­é™£åˆ—åˆ°ç¥ç¶“ç¶²è·¯ç‰¹å¾µå¹³é¢ï¼Œæ·±å…¥ç†è§£åœæ£‹ AI å¦‚ä½•ã€Œçœ‹ã€æ£‹ç›¤
keywords: [æ£‹ç›¤è¡¨ç¤º, Zobrist Hashing, Union-Find, ç‰¹å¾µç·¨ç¢¼, AlphaGoç‰¹å¾µå¹³é¢]
---

import { GoBoard } from '@site/src/components/D3Charts';

# æ£‹ç›¤ç‹€æ…‹è¡¨ç¤º

åœ¨è¨­è¨ˆåœæ£‹ AI ä¹‹å‰ï¼Œé¦–å…ˆè¦è§£æ±ºä¸€å€‹åŸºæœ¬å•é¡Œï¼š**å¦‚ä½•è®“é›»è…¦ã€Œçœ‹æ‡‚ã€æ£‹ç›¤ï¼Ÿ**

é€™å€‹å•é¡Œçœ‹ä¼¼ç°¡å–®ï¼Œå»æ¶‰åŠåˆ°è³‡æ–™çµæ§‹ã€æ¼”ç®—æ³•ã€ä»¥åŠç¥ç¶“ç¶²è·¯è¼¸å…¥è¨­è¨ˆç­‰å¤šå€‹å±¤é¢ã€‚æœ¬æ–‡å°‡å¾æœ€åŸºç¤çš„äºŒç¶­é™£åˆ—é–‹å§‹ï¼Œé€æ­¥ä»‹ç´¹åœæ£‹ AI ä½¿ç”¨çš„å„ç¨®æ£‹ç›¤è¡¨ç¤ºæ–¹æ³•ï¼Œæœ€çµ‚èªªæ˜ AlphaGo å¦‚ä½•å°‡æ£‹ç›¤ç·¨ç¢¼æˆç¥ç¶“ç¶²è·¯å¯ä»¥è™•ç†çš„æ ¼å¼ã€‚

---

## äºŒç¶­é™£åˆ—è¡¨ç¤ºï¼šæœ€ç›´è§€çš„æ–¹å¼

### åŸºæœ¬æ¦‚å¿µ

åœæ£‹æ£‹ç›¤æ˜¯ä¸€å€‹ 19Ã—19 çš„æ–¹æ ¼ç¶²è·¯ï¼Œæœ€ç›´è§€çš„è¡¨ç¤ºæ–¹å¼å°±æ˜¯ä½¿ç”¨**äºŒç¶­é™£åˆ—**ï¼š

```python
import numpy as np

# æ£‹ç›¤å¸¸æ•¸
BOARD_SIZE = 19
EMPTY = 0
BLACK = 1
WHITE = 2

# åˆå§‹åŒ–ç©ºæ£‹ç›¤
board = np.zeros((BOARD_SIZE, BOARD_SIZE), dtype=np.int8)

# è½å­ï¼šé»‘å­åœ¨ D4 (3, 3)
board[3, 3] = BLACK

# è½å­ï¼šç™½å­åœ¨ Q16 (15, 3)
board[15, 3] = WHITE
```

### åº§æ¨™ç³»çµ±

åœæ£‹ä½¿ç”¨å…©ç¨®å¸¸è¦‹çš„åº§æ¨™ç³»çµ±ï¼š

#### 1. æ•¸å­—åº§æ¨™ï¼ˆç¨‹å¼ç”¨ï¼‰

```
    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18
0   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
1   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
2   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
3   .  .  .  â—  .  .  .  .  .  +  .  .  .  .  .  â—‹  .  .  .
...
```

#### 2. å­—æ¯-æ•¸å­—åº§æ¨™ï¼ˆæ£‹è­œç”¨ï¼‰

```
    A  B  C  D  E  F  G  H  J  K  L  M  N  O  P  Q  R  S  T
19  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
18  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
17  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
16  .  .  .  â—  .  .  .  .  .  +  .  .  .  .  .  â—‹  .  .  .
...
```

æ³¨æ„ï¼šå­—æ¯åº§æ¨™è·³é "I"ï¼ˆé¿å…èˆ‡æ•¸å­— 1 æ··æ·†ï¼‰ã€‚

### åº§æ¨™è½‰æ›å‡½æ•¸

```python
def coord_to_index(coord):
    """
    å°‡æ£‹è­œåº§æ¨™è½‰æ›ç‚ºé™£åˆ—ç´¢å¼•
    ä¾‹å¦‚ï¼š'D4' -> (3, 15)
    """
    letters = 'ABCDEFGHJKLMNOPQRST'  # è·³é I
    col = letters.index(coord[0].upper())
    row = BOARD_SIZE - int(coord[1:])
    return row, col


def index_to_coord(row, col):
    """
    å°‡é™£åˆ—ç´¢å¼•è½‰æ›ç‚ºæ£‹è­œåº§æ¨™
    ä¾‹å¦‚ï¼š(3, 15) -> 'Q16'
    """
    letters = 'ABCDEFGHJKLMNOPQRST'
    return f"{letters[col]}{BOARD_SIZE - row}"
```

### ç©ºé–“è¤‡é›œåº¦åˆ†æ

äºŒç¶­é™£åˆ—è¡¨ç¤ºçš„ç©ºé–“è¤‡é›œåº¦ï¼š

| è¡¨ç¤ºæ–¹å¼ | æ¯æ ¼å¤§å° | ç¸½ç©ºé–“ |
|---------|---------|--------|
| `int8` | 1 byte | 361 bytes |
| `int32` | 4 bytes | 1.4 KB |
| `float64` | 8 bytes | 2.9 KB |

å°æ–¼ç¾ä»£é›»è…¦ä¾†èªªï¼Œé€™é»è¨˜æ†¶é«”å®Œå…¨ä¸æ˜¯å•é¡Œã€‚ä½†åœ¨éœ€è¦å„²å­˜å¤§é‡æ£‹ç›¤ç‹€æ…‹ï¼ˆå¦‚ MCTS æœç´¢æ¨¹ï¼‰æ™‚ï¼Œä½¿ç”¨ `int8` å¯ä»¥é¡¯è‘—æ¸›å°‘è¨˜æ†¶é«”ä½¿ç”¨ã€‚

### åŸºæœ¬æ“ä½œ

```python
class Board:
    def __init__(self, size=19):
        self.size = size
        self.board = np.zeros((size, size), dtype=np.int8)
        self.current_player = BLACK
        self.ko_point = None  # æ‰“åŠ«ç¦è‘—é»
        self.move_history = []

    def is_valid_move(self, row, col):
        """æª¢æŸ¥è½å­æ˜¯å¦åˆæ³•"""
        # 1. ä½ç½®åœ¨æ£‹ç›¤å…§
        if not (0 <= row < self.size and 0 <= col < self.size):
            return False

        # 2. ä½ç½®æ˜¯ç©ºçš„
        if self.board[row, col] != EMPTY:
            return False

        # 3. ä¸æ˜¯æ‰“åŠ«ç¦è‘—é»
        if self.ko_point == (row, col):
            return False

        # 4. ä¸æ˜¯è‡ªæ®ºï¼ˆé™¤éèƒ½æå­ï¼‰
        # ... éœ€è¦æ›´è¤‡é›œçš„æª¢æŸ¥

        return True

    def place_stone(self, row, col):
        """è½å­"""
        if not self.is_valid_move(row, col):
            return False

        self.board[row, col] = self.current_player
        self.move_history.append((row, col))

        # è™•ç†æå­
        captures = self._remove_captured_stones(row, col)

        # æ›´æ–°æ‰“åŠ«ç¦è‘—é»
        self._update_ko(row, col, captures)

        # åˆ‡æ›ç©å®¶
        self.current_player = WHITE if self.current_player == BLACK else BLACK

        return True
```

---

## Zobrist Hashingï¼šå¿«é€Ÿè­˜åˆ¥é‡è¤‡å±€é¢

### å•é¡ŒèƒŒæ™¯

åœ¨åœæ£‹ AI ä¸­ï¼Œæˆ‘å€‘ç¶“å¸¸éœ€è¦åˆ¤æ–·ã€Œå…©å€‹å±€é¢æ˜¯å¦ç›¸åŒã€ï¼š

1. **æ‰“åŠ«è¦å‰‡**ï¼šä¸èƒ½è®“å±€é¢å›åˆ°ä¸Šä¸€æ‰‹çš„ç‹€æ…‹
2. **ä¸‰åŠ«å¾ªç’°**ï¼šç‰¹æ®Šè¦å‰‡è™•ç†
3. **Transposition Table**ï¼šè¨˜æ†¶å·²æœç´¢éçš„å±€é¢
4. **ç¥ç¶“ç¶²è·¯å¿«å–**ï¼šé¿å…é‡è¤‡è¨ˆç®—

å¦‚æœæ¯æ¬¡éƒ½é€æ ¼æ¯”è¼ƒï¼Œéœ€è¦ O(361) çš„æ™‚é–“ã€‚æœ‰æ²’æœ‰æ›´å¿«çš„æ–¹æ³•ï¼Ÿ

### Zobrist Hashing åŸç†

**Zobrist Hashing**ï¼ˆåˆç¨± Zobrist Keysï¼‰æ˜¯ä¸€ç¨®å·§å¦™çš„é›œæ¹Šæ–¹æ³•ï¼Œç”± Albert Zobrist åœ¨ 1970 å¹´æå‡ºã€‚å…¶æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š

1. ç‚ºæ¯å€‹ã€Œä½ç½® Ã— é¡è‰²ã€çš„çµ„åˆé å…ˆç”Ÿæˆä¸€å€‹**éš¨æ©Ÿæ•¸**
2. æ£‹ç›¤çš„é›œæ¹Šå€¼ = æ‰€æœ‰æœ‰æ£‹å­ä½ç½®çš„éš¨æ©Ÿæ•¸çš„ **XOR**
3. è½å­/æå­åªéœ€è¦ä¸€æ¬¡ XOR é‹ç®—å³å¯æ›´æ–°é›œæ¹Šå€¼

### éš¨æ©Ÿæ•¸è¡¨

```python
import numpy as np

# ç”Ÿæˆéš¨æ©Ÿæ•¸è¡¨
# ä½¿ç”¨å›ºå®šç¨®å­ç¢ºä¿å¯é‡è¤‡æ€§
np.random.seed(42)

# æ¯å€‹ä½ç½®ã€æ¯ç¨®é¡è‰²å„ä¸€å€‹éš¨æ©Ÿæ•¸
# zobrist[color][row][col]
zobrist_table = np.random.randint(
    0, 2**64,
    size=(3, BOARD_SIZE, BOARD_SIZE),  # 3: EMPTY, BLACK, WHITE
    dtype=np.uint64
)

# è¼ªåˆ°èª°ä¸‹æ£‹çš„éš¨æ©Ÿæ•¸
zobrist_player = np.random.randint(0, 2**64, dtype=np.uint64)
```

### XOR é‹ç®—çš„ç‰¹æ€§

XORï¼ˆç•°æˆ–ï¼‰é‹ç®—æœ‰å¹¾å€‹é‡è¦ç‰¹æ€§ä½¿å®ƒéå¸¸é©åˆé€™å€‹æ‡‰ç”¨ï¼š

1. **è‡ªåæ€§**ï¼šA âŠ• A = 0ï¼ˆåŒä¸€å€‹æ•¸ XOR è‡ªå·±ç­‰æ–¼ 0ï¼‰
2. **å¯é€†æ€§**ï¼šA âŠ• B âŠ• B = Aï¼ˆXOR å…©æ¬¡ç­‰æ–¼æ²’æœ‰ï¼‰
3. **äº¤æ›å¾‹**ï¼šA âŠ• B = B âŠ• A
4. **çµåˆå¾‹**ï¼š(A âŠ• B) âŠ• C = A âŠ• (B âŠ• C)

é€™æ„å‘³è‘—ï¼š
- è½å­ï¼š`hash ^= zobrist[color][row][col]`
- æå­ï¼š`hash ^= zobrist[color][row][col]`ï¼ˆåŒæ¨£çš„æ“ä½œï¼ï¼‰

### å¯¦ç¾

```python
class ZobristBoard:
    def __init__(self, size=19):
        self.size = size
        self.board = np.zeros((size, size), dtype=np.int8)
        self.current_player = BLACK
        self.hash = np.uint64(0)

        # åˆå§‹åŒ–éš¨æ©Ÿæ•¸è¡¨
        self._init_zobrist_table()

    def _init_zobrist_table(self):
        np.random.seed(12345)
        self.zobrist = np.random.randint(
            0, 2**64,
            size=(3, self.size, self.size),
            dtype=np.uint64
        )
        self.zobrist_player = np.random.randint(0, 2**64, dtype=np.uint64)

    def place_stone(self, row, col, color):
        """è½å­ä¸¦æ›´æ–°é›œæ¹Šå€¼"""
        # ç§»é™¤èˆŠç‹€æ…‹ï¼ˆå¦‚æœæœ‰æ£‹å­ï¼‰
        old_color = self.board[row, col]
        if old_color != EMPTY:
            self.hash ^= self.zobrist[old_color, row, col]

        # æ·»åŠ æ–°æ£‹å­
        self.board[row, col] = color
        self.hash ^= self.zobrist[color, row, col]

    def remove_stone(self, row, col):
        """æå­ä¸¦æ›´æ–°é›œæ¹Šå€¼"""
        color = self.board[row, col]
        if color != EMPTY:
            self.hash ^= self.zobrist[color, row, col]
            self.board[row, col] = EMPTY

    def switch_player(self):
        """åˆ‡æ›ç©å®¶ä¸¦æ›´æ–°é›œæ¹Šå€¼"""
        self.hash ^= self.zobrist_player
        self.current_player = WHITE if self.current_player == BLACK else BLACK

    def get_hash(self):
        """ç²å–ç•¶å‰å±€é¢çš„é›œæ¹Šå€¼"""
        return self.hash
```

### å¢é‡æ›´æ–°çš„å„ªå‹¢

ä½¿ç”¨ Zobrist Hashingï¼Œæ›´æ–°é›œæ¹Šå€¼åªéœ€è¦ O(1) æ™‚é–“ï¼š

| æ“ä½œ | å‚³çµ±æ¯”è¼ƒ | Zobrist |
|------|---------|---------|
| æ¯”è¼ƒå…©å€‹å±€é¢ | O(361) | O(1) |
| è½å­å¾Œæ›´æ–° | O(361) | O(1) |
| æå­å¾Œæ›´æ–° | O(361) | O(k)ï¼Œk æ˜¯æå­æ•¸ |

### ç¢°æ’æ©Ÿç‡

ä½¿ç”¨ 64 ä½å…ƒé›œæ¹Šï¼Œç¢°æ’æ©Ÿç‡æ¥µä½ï¼š

**P(ç¢°æ’) â‰ˆ nÂ² / 2^65**

å…¶ä¸­ n æ˜¯ä¸åŒå±€é¢çš„æ•¸é‡ã€‚å³ä½¿æœ‰ 10 å„„å€‹å±€é¢ï¼Œç¢°æ’æ©Ÿç‡ä¹Ÿåªæœ‰ç´„ 10^-3ã€‚

å¯¦éš›ä¸Šï¼Œè¨±å¤šåœæ£‹ç¨‹å¼ä½¿ç”¨ 64 ä½å…ƒ Zobrist Hashing è€Œä¸åšç¢°æ’æª¢æŸ¥ï¼Œå› ç‚ºç¢°æ’æ©Ÿç‡ä½åˆ°å¯ä»¥å¿½ç•¥ã€‚

---

## æ£‹ä¸²è¡¨ç¤ºï¼ˆUnion-Findï¼‰ï¼šé€£é€šæ€§å•é¡Œ

### æ£‹ä¸²çš„æ¦‚å¿µ

åœ¨åœæ£‹ä¸­ï¼Œ**æ£‹ä¸²**ï¼ˆString æˆ– Chainï¼‰æ˜¯æŒ‡ä¸€çµ„ç›¸é€£çš„åŒè‰²æ£‹å­ã€‚æ£‹ä¸²çš„ã€Œæ°£ã€æ±ºå®šäº†å®ƒçš„æ­»æ´»ã€‚

<GoBoard
  size={200}
  stones={[
    {x: 3, y: 3, color: 'black'},
    {x: 4, y: 3, color: 'black'},
    {x: 5, y: 3, color: 'black'},
    {x: 4, y: 4, color: 'black'},
    {x: 6, y: 3, color: 'white'},
    {x: 6, y: 4, color: 'white'},
  ]}
  labels={[
    {x: 4, y: 3, text: 'A'},
  ]}
/>

åœ¨ä¸Šåœ–ä¸­ï¼Œå››é¡†é»‘å­å½¢æˆä¸€å€‹æ£‹ä¸²ï¼Œé€™å€‹æ£‹ä¸²çš„æ°£æ•¸æ±ºå®šäº†å®ƒçš„ç”Ÿæ­»ã€‚

### ç‚ºä»€éº¼éœ€è¦é«˜æ•ˆçš„æ£‹ä¸²ç®¡ç†ï¼Ÿ

æ¯æ¬¡è½å­éƒ½å¯èƒ½ï¼š
1. **å‰µå»º**æ–°æ£‹ä¸²
2. **åˆä½µ**å¤šå€‹æ£‹ä¸²
3. **æ¸›å°‘**æ•µæ–¹æ£‹ä¸²çš„æ°£
4. **ææ‰**æ²’æœ‰æ°£çš„æ£‹ä¸²

é€™äº›æ“ä½œéœ€è¦é«˜æ•ˆåŸ·è¡Œï¼Œå› ç‚ºåœ¨ MCTS ä¸­ï¼Œä¸€ç§’é˜å¯èƒ½éœ€è¦é€²è¡Œæ•¸è¬æ¬¡è½å­æ¨¡æ“¬ã€‚

### Union-Find è³‡æ–™çµæ§‹

**Union-Find**ï¼ˆåˆç¨± Disjoint Set Union, DSUï¼‰æ˜¯è™•ç†ã€Œé€£é€šæ€§ã€å•é¡Œçš„ç¶“å…¸è³‡æ–™çµæ§‹ï¼š

```python
class UnionFind:
    def __init__(self, size):
        # parent[i] æŒ‡å‘ i çš„çˆ¶ç¯€é»
        # å¦‚æœ parent[i] = iï¼Œå‰‡ i æ˜¯æ ¹ç¯€é»
        self.parent = list(range(size))
        self.rank = [0] * size

    def find(self, x):
        """
        æ‰¾åˆ° x æ‰€å±¬é›†åˆçš„æ ¹ç¯€é»ï¼ˆå¸¶è·¯å¾‘å£“ç¸®ï¼‰
        """
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # è·¯å¾‘å£“ç¸®
        return self.parent[x]

    def union(self, x, y):
        """
        åˆä½µ x å’Œ y æ‰€å±¬çš„é›†åˆï¼ˆå¸¶æŒ‰ç§©åˆä½µï¼‰
        """
        root_x = self.find(x)
        root_y = self.find(y)

        if root_x == root_y:
            return  # å·²ç¶“åœ¨åŒä¸€é›†åˆ

        # æŒ‰ç§©åˆä½µï¼šå°‡è¼ƒå°çš„æ¨¹é€£åˆ°è¼ƒå¤§çš„æ¨¹
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1
```

### æ™‚é–“è¤‡é›œåº¦

Union-Find çš„æ™‚é–“è¤‡é›œåº¦ä½¿ç”¨**åé˜¿å…‹æ›¼å‡½æ•¸** Î±(n) ä¾†è¡¨ç¤ºï¼š

| æ“ä½œ | æ™‚é–“è¤‡é›œåº¦ |
|------|-----------|
| find | O(Î±(n)) â‰ˆ O(1) |
| union | O(Î±(n)) â‰ˆ O(1) |

Î±(n) å¢é•·æ¥µæ…¢ï¼Œå°æ–¼ä»»ä½•å¯¦éš›çš„ nï¼ŒÎ±(n) â‰¤ 4ã€‚å› æ­¤å¯ä»¥èªç‚ºæ˜¯å¸¸æ•¸æ™‚é–“ã€‚

### åœæ£‹ä¸­çš„ Union-Find æ‡‰ç”¨

```python
class GoStringManager:
    def __init__(self, size=19):
        self.size = size
        num_points = size * size

        # Union-Find çµæ§‹
        self.parent = list(range(num_points))
        self.rank = [0] * num_points

        # æ¯å€‹æ£‹ä¸²çš„æ°£ï¼ˆç”¨æ ¹ç¯€é»ç´¢å¼•ï¼‰
        self.liberties = [set() for _ in range(num_points)]

        # æ¯å€‹æ£‹ä¸²çš„æ£‹å­ï¼ˆç”¨æ ¹ç¯€é»ç´¢å¼•ï¼‰
        self.stones = [set() for _ in range(num_points)]

    def _index(self, row, col):
        return row * self.size + col

    def _neighbors(self, row, col):
        """ç²å–å››é„°"""
        neighbors = []
        if row > 0: neighbors.append((row - 1, col))
        if row < self.size - 1: neighbors.append((row + 1, col))
        if col > 0: neighbors.append((row, col - 1))
        if col < self.size - 1: neighbors.append((row, col + 1))
        return neighbors

    def find(self, idx):
        if self.parent[idx] != idx:
            self.parent[idx] = self.find(self.parent[idx])
        return self.parent[idx]

    def add_stone(self, row, col, color, board):
        """
        æ·»åŠ ä¸€é¡†æ£‹å­ï¼Œè™•ç†é€£æ¥å’Œæå­
        """
        idx = self._index(row, col)

        # å‰µå»ºæ–°æ£‹ä¸²
        self.stones[idx] = {idx}
        self.liberties[idx] = set()

        # è¨ˆç®—é€™é¡†æ£‹å­çš„æ°£
        for nr, nc in self._neighbors(row, col):
            nidx = self._index(nr, nc)
            if board[nr, nc] == 0:  # ç©ºé»æ˜¯æ°£
                self.liberties[idx].add(nidx)

        # èˆ‡åŒè‰²é„°å±…åˆä½µ
        for nr, nc in self._neighbors(row, col):
            nidx = self._index(nr, nc)
            if board[nr, nc] == color:
                self._merge_strings(idx, nidx)

        # æ¸›å°‘æ•µæ–¹æ£‹ä¸²çš„æ°£
        opponent = 3 - color  # BLACK=1, WHITE=2
        captured = []
        for nr, nc in self._neighbors(row, col):
            nidx = self._index(nr, nc)
            if board[nr, nc] == opponent:
                root = self.find(nidx)
                self.liberties[root].discard(idx)
                if len(self.liberties[root]) == 0:
                    captured.append(root)

        return captured

    def _merge_strings(self, idx1, idx2):
        """åˆä½µå…©å€‹æ£‹ä¸²"""
        root1 = self.find(idx1)
        root2 = self.find(idx2)

        if root1 == root2:
            return

        # æŒ‰ç§©åˆä½µ
        if self.rank[root1] < self.rank[root2]:
            root1, root2 = root2, root1

        self.parent[root2] = root1
        if self.rank[root1] == self.rank[root2]:
            self.rank[root1] += 1

        # åˆä½µæ°£å’Œæ£‹å­é›†åˆ
        self.liberties[root1] |= self.liberties[root2]
        self.stones[root1] |= self.stones[root2]

        # ç§»é™¤è‡ªå·±ä½ç½®çš„æ°£ï¼ˆè‡ªå·±ä¸æ˜¯è‡ªå·±çš„æ°£ï¼‰
        for stone_idx in self.stones[root2]:
            self.liberties[root1].discard(stone_idx)
```

### æ°£çš„è¨ˆç®—

è¨ˆç®—æ£‹ä¸²çš„æ°£æ•¸æ˜¯åœæ£‹ä¸­æœ€å¸¸è¦‹çš„æ“ä½œä¹‹ä¸€ï¼š

```python
def count_liberties(self, row, col, board):
    """è¨ˆç®—æŸé¡†æ£‹å­æ‰€å±¬æ£‹ä¸²çš„æ°£æ•¸"""
    idx = self._index(row, col)
    root = self.find(idx)
    return len(self.liberties[root])
```

ä½¿ç”¨ Union-Findï¼Œé€™å€‹æ“ä½œæ˜¯ O(1) çš„ï¼ˆå‡è¨­ find æ˜¯ O(1)ï¼‰ã€‚

---

## ç‰¹å¾µç·¨ç¢¼çš„æ¼”é€²

å¾å‚³çµ±çš„æ‰‹å·¥ç‰¹å¾µåˆ° AlphaGo Zero çš„ç°¡æ½”ç‰¹å¾µï¼Œåœæ£‹ AI çš„ç‰¹å¾µç·¨ç¢¼ç¶“æ­·äº†é‡å¤§æ¼”é€²ã€‚

### GNU Go çš„æ‰‹å·¥ç‰¹å¾µ

æ—©æœŸçš„åœæ£‹ç¨‹å¼ï¼ˆå¦‚ GNU Goï¼‰ä½¿ç”¨å¤§é‡æ‰‹å·¥è¨­è¨ˆçš„ç‰¹å¾µï¼š

```python
def extract_features_gnugo(board, point):
    """
    GNU Go é¢¨æ ¼çš„æ‰‹å·¥ç‰¹å¾µæå–
    """
    features = {}

    # 1. æ£‹å½¢æ¨¡å¼ï¼ˆé å®šç¾©çš„å±€éƒ¨å½¢ç‹€ï¼‰
    features['pattern'] = match_pattern(board, point)

    # 2. æˆ°è¡“ç‰¹å¾µ
    features['can_capture'] = check_capture(board, point)
    features['can_connect'] = check_connect(board, point)
    features['creates_eye'] = check_eye_creation(board, point)

    # 3. å±€éƒ¨ç‰¹å¾µ
    features['liberties_after'] = count_liberties_after_move(board, point)
    features['enemy_liberties'] = count_enemy_liberties(board, point)

    # 4. å…¨å±€ç‰¹å¾µ
    features['distance_to_edge'] = min(
        point[0], point[1],
        18 - point[0], 18 - point[1]
    )

    # ... æ›´å¤šç‰¹å¾µ

    return features
```

é€™ç¨®æ–¹æ³•çš„å•é¡Œï¼š
- éœ€è¦å¤§é‡äººé¡å°ˆå®¶çŸ¥è­˜
- ç‰¹å¾µå¯èƒ½ä¸å®Œæ•´
- é›£ä»¥ç™¼ç¾æ–°çš„æ¨¡å¼

### AlphaGo çš„ 48 å€‹ç‰¹å¾µå¹³é¢

AlphaGoï¼ˆ2016 Nature ç‰ˆæœ¬ï¼‰ä½¿ç”¨äº† **48 å€‹ç‰¹å¾µå¹³é¢**ä½œç‚ºç¥ç¶“ç¶²è·¯çš„è¼¸å…¥ï¼š

```python
def encode_alphago_features(board, player, history):
    """
    AlphaGo 2016 çš„ 48 å€‹ç‰¹å¾µå¹³é¢

    Returns:
        (19, 19, 48) çš„å¼µé‡
    """
    features = np.zeros((19, 19, 48), dtype=np.float32)

    # å¹³é¢ 1: é»‘å­ä½ç½®
    features[:, :, 0] = (board == BLACK)

    # å¹³é¢ 2: ç™½å­ä½ç½®
    features[:, :, 1] = (board == WHITE)

    # å¹³é¢ 3: ç©ºé»
    features[:, :, 2] = (board == EMPTY)

    # å¹³é¢ 4: å…¨ 1ï¼ˆåç½®é …ï¼‰
    features[:, :, 3] = 1

    # å¹³é¢ 5-12: æ°£æ•¸ç·¨ç¢¼ï¼ˆ1-8æ°£å„ä¸€å€‹å¹³é¢ï¼‰
    for i, num_libs in enumerate(range(1, 9)):
        for r in range(19):
            for c in range(19):
                if board[r, c] != EMPTY:
                    libs = count_liberties(board, r, c)
                    if libs == num_libs:
                        features[r, c, 4 + i] = 1

    # å¹³é¢ 13-20: æå­å¾Œå°æ–¹æ°£æ•¸
    # ...

    # å¹³é¢ 21-28: è‡ªå·±è½å­å¾Œçš„æ°£æ•¸
    # ...

    # å¹³é¢ 29-36: éå» 8 æ­¥çš„æ­·å²ï¼ˆæ¯æ­¥ä¸€å€‹å¹³é¢ï¼‰
    for i, (r, c) in enumerate(history[-8:]):
        features[r, c, 28 + i] = 1

    # å¹³é¢ 37-44: å¾å­åˆ¤æ–·
    # ...

    # å¹³é¢ 45-48: å°ç¨±æ€§ç›¸é—œ
    # ...

    # å¹³é¢ 49: è¼ªåˆ°èª°ä¸‹ï¼ˆå…¨ 1 è¡¨ç¤ºé»‘ï¼Œå…¨ 0 è¡¨ç¤ºç™½ï¼‰
    if player == BLACK:
        features[:, :, 47] = 1

    return features
```

### 48 å€‹å¹³é¢çš„åˆ†é¡

| é¡åˆ¥ | å¹³é¢æ•¸ | èªªæ˜ |
|------|--------|------|
| æ£‹å­ä½ç½® | 3 | é»‘å­ã€ç™½å­ã€ç©ºé» |
| å¸¸æ•¸ | 1 | å…¨ 1 |
| æ°£æ•¸ | 8 | 1-8 æ°£ |
| æå­å¾Œæ°£æ•¸ | 8 | å‡è¨­è½å­å¾Œçš„æ°£æ•¸ |
| è½å­å¾Œæ°£æ•¸ | 8 | å‡è¨­è½å­å¾Œçš„æ°£æ•¸ |
| æ­·å² | 8 | éå» 8 æ­¥ |
| å¾å­ | 8 | è¤‡é›œçš„å¾å­åˆ†æ |
| å…¶ä»– | 4 | è¼ªæ¬¡ã€å°ç¨±æ€§ç­‰ |

### AlphaGo Zero çš„ 17 å€‹ç‰¹å¾µå¹³é¢

AlphaGo Zeroï¼ˆ2017ï¼‰å¤§å¹…ç°¡åŒ–äº†ç‰¹å¾µç·¨ç¢¼ï¼Œåªä½¿ç”¨ **17 å€‹å¹³é¢**ï¼š

```python
def encode_alphago_zero_features(board_history, player):
    """
    AlphaGo Zero çš„ 17 å€‹ç‰¹å¾µå¹³é¢

    Args:
        board_history: éå» 8 å€‹å±€é¢ï¼ˆåŒ…æ‹¬ç•¶å‰ï¼‰
        player: ç•¶å‰ç©å®¶

    Returns:
        (19, 19, 17) çš„å¼µé‡
    """
    features = np.zeros((19, 19, 17), dtype=np.float32)

    # å¹³é¢ 1-8: é»‘å­æ­·å²ï¼ˆæœ€è¿‘ 8 æ­¥ï¼‰
    for i, board in enumerate(board_history[-8:]):
        features[:, :, i] = (board == BLACK)

    # å¹³é¢ 9-16: ç™½å­æ­·å²ï¼ˆæœ€è¿‘ 8 æ­¥ï¼‰
    for i, board in enumerate(board_history[-8:]):
        features[:, :, 8 + i] = (board == WHITE)

    # å¹³é¢ 17: è¼ªåˆ°èª°ä¸‹ï¼ˆå…¨ 1 è¡¨ç¤ºé»‘ï¼Œå…¨ 0 è¡¨ç¤ºç™½ï¼‰
    if player == BLACK:
        features[:, :, 16] = 1

    return features
```

### 17 å€‹å¹³é¢çš„ç°¡æ½”æ€§

| é¡åˆ¥ | å¹³é¢æ•¸ | èªªæ˜ |
|------|--------|------|
| é»‘å­æ­·å² | 8 | éå» 8 å€‹æ™‚é–“æ­¥çš„é»‘å­ä½ç½® |
| ç™½å­æ­·å² | 8 | éå» 8 å€‹æ™‚é–“æ­¥çš„ç™½å­ä½ç½® |
| ç•¶å‰ç©å®¶ | 1 | å…¨ 1 æˆ–å…¨ 0 |

ç‚ºä»€éº¼å¯ä»¥é€™éº¼ç°¡æ½”ï¼Ÿ

> **é—œéµæ´è¦‹ï¼šè®“ç¥ç¶“ç¶²è·¯è‡ªå·±å­¸ç¿’ç‰¹å¾µã€‚**

AlphaGo Zero è­‰æ˜äº†ï¼š
- ä¸éœ€è¦æ‰‹å·¥è¨ˆç®—æ°£æ•¸ï¼ˆç¶²è·¯å¯ä»¥å¾æ£‹å­ä½ç½®æ¨æ–·ï¼‰
- ä¸éœ€è¦å¾å­åˆ†æï¼ˆç¶²è·¯å¯ä»¥å­¸æœƒè­˜åˆ¥å¾å­ï¼‰
- ä¸éœ€è¦è¤‡é›œçš„æå­é æ¸¬ï¼ˆç¶²è·¯å¯ä»¥ç†è§£è½å­å¾Œæœï¼‰

é€™é«”ç¾äº†æ·±åº¦å­¸ç¿’çš„æ ¸å¿ƒå„ªå‹¢ï¼š**ç«¯åˆ°ç«¯å­¸ç¿’**ã€‚

### ç‰¹å¾µå¹³é¢çš„è¦–è¦ºåŒ–

è®“æˆ‘å€‘çœ‹ä¸€ä¸‹é€™äº›ç‰¹å¾µå¹³é¢å¯¦éš›é•·ä»€éº¼æ¨£ï¼š

```
åŸå§‹æ£‹ç›¤ï¼š              é»‘å­å¹³é¢ï¼š              ç™½å­å¹³é¢ï¼š
. . . . . .            0 0 0 0 0 0            0 0 0 0 0 0
. â— â—‹ . . .            0 1 0 0 0 0            0 0 1 0 0 0
. . â— â—‹ . .    ->      0 0 1 0 0 0     +      0 0 0 1 0 0
. . . â— . .            0 0 0 1 0 0            0 0 0 0 0 0
. . . . . .            0 0 0 0 0 0            0 0 0 0 0 0
```

æ¯å€‹å¹³é¢éƒ½æ˜¯ä¸€å€‹äºŒå…ƒçŸ©é™£ï¼ˆ0 æˆ– 1ï¼‰ï¼Œç¥ç¶“ç¶²è·¯å¯ä»¥é€šéå·ç©æ“ä½œä¾†æå–é€™äº›å¹³é¢ä¸­çš„æ¨¡å¼ã€‚

---

## å°ç¨±æ€§è™•ç†ï¼š8 ç¨®è®Šæ›

### åœæ£‹çš„å°ç¨±æ€§

åœæ£‹æ£‹ç›¤å…·æœ‰ **8 ç¨®å°ç¨±æ€§**ï¼š

1. **4 ç¨®æ—‹è½‰**ï¼š0Â°ã€90Â°ã€180Â°ã€270Â°
2. **4 ç¨®ç¿»è½‰å¾Œæ—‹è½‰**ï¼šæ°´å¹³ç¿»è½‰ + 4 ç¨®æ—‹è½‰

é€™å½¢æˆäº†ä¸€å€‹ **äºŒé¢é«”ç¾¤ D4**ã€‚

### æ•¸å­¸è¡¨ç¤º

è¨­ (x, y) ç‚ºæ£‹ç›¤ä¸Šçš„åº§æ¨™ï¼ˆä¸­å¿ƒåœ¨ (9, 9)ï¼‰ï¼Œ8 ç¨®è®Šæ›å¯ä»¥è¡¨ç¤ºç‚ºï¼š

| è®Šæ› | å…¬å¼ |
|------|------|
| æ†ç­‰ | (x, y) |
| æ—‹è½‰ 90Â° | (-y, x) |
| æ—‹è½‰ 180Â° | (-x, -y) |
| æ—‹è½‰ 270Â° | (y, -x) |
| æ°´å¹³ç¿»è½‰ | (-x, y) |
| å‚ç›´ç¿»è½‰ | (x, -y) |
| å°è§’ç¿»è½‰ | (y, x) |
| åå°è§’ç¿»è½‰ | (-y, -x) |

### ç¨‹å¼å¯¦ç¾

```python
def get_symmetries(board):
    """
    ç²å–æ£‹ç›¤çš„ 8 ç¨®å°ç¨±è®Šæ›

    Returns:
        8 å€‹æ£‹ç›¤çš„åˆ—è¡¨
    """
    symmetries = []

    # åŸå§‹
    symmetries.append(board.copy())

    # æ—‹è½‰ 90Â°
    symmetries.append(np.rot90(board, k=1))

    # æ—‹è½‰ 180Â°
    symmetries.append(np.rot90(board, k=2))

    # æ—‹è½‰ 270Â°
    symmetries.append(np.rot90(board, k=3))

    # æ°´å¹³ç¿»è½‰
    symmetries.append(np.fliplr(board))

    # å‚ç›´ç¿»è½‰
    symmetries.append(np.flipud(board))

    # å°è§’ç¿»è½‰
    symmetries.append(board.T)

    # åå°è§’ç¿»è½‰
    symmetries.append(np.rot90(board.T, k=2))

    return symmetries


def apply_symmetry(board, sym_index):
    """
    æ‡‰ç”¨ç¬¬ sym_index ç¨®å°ç¨±è®Šæ›
    """
    return get_symmetries(board)[sym_index]


def inverse_symmetry(move, sym_index, board_size=19):
    """
    å°‡è®Šæ›å¾Œçš„è½å­åº§æ¨™è½‰å›åŸå§‹åº§æ¨™
    """
    row, col = move

    if sym_index == 0:  # æ†ç­‰
        return row, col
    elif sym_index == 1:  # æ—‹è½‰ 90Â°
        return col, board_size - 1 - row
    elif sym_index == 2:  # æ—‹è½‰ 180Â°
        return board_size - 1 - row, board_size - 1 - col
    elif sym_index == 3:  # æ—‹è½‰ 270Â°
        return board_size - 1 - col, row
    elif sym_index == 4:  # æ°´å¹³ç¿»è½‰
        return row, board_size - 1 - col
    elif sym_index == 5:  # å‚ç›´ç¿»è½‰
        return board_size - 1 - row, col
    elif sym_index == 6:  # å°è§’ç¿»è½‰
        return col, row
    elif sym_index == 7:  # åå°è§’ç¿»è½‰
        return board_size - 1 - col, board_size - 1 - row
```

### è³‡æ–™å¢å¼·

åœ¨è¨“ç·´ç¥ç¶“ç¶²è·¯æ™‚ï¼Œå¯ä»¥åˆ©ç”¨å°ç¨±æ€§é€²è¡Œ**è³‡æ–™å¢å¼·**ï¼š

```python
def augment_training_data(board, policy, value):
    """
    å°‡ä¸€å€‹è¨“ç·´æ¨£æœ¬æ“´å±•ç‚º 8 å€‹
    """
    augmented = []

    for sym_index in range(8):
        # è®Šæ›æ£‹ç›¤
        aug_board = apply_symmetry(board, sym_index)

        # è®Šæ›ç­–ç•¥ï¼ˆ361 ç¶­å‘é‡ï¼‰
        policy_2d = policy.reshape(19, 19)
        aug_policy_2d = apply_symmetry(policy_2d, sym_index)
        aug_policy = aug_policy_2d.flatten()

        # åƒ¹å€¼ä¸è®Š
        aug_value = value

        augmented.append((aug_board, aug_policy, aug_value))

    return augmented
```

é€™è®“è¨“ç·´è³‡æ–™é‡å¢åŠ  8 å€ï¼Œä¸”å®Œå…¨å…è²»ï¼ˆä¸éœ€è¦æ”¶é›†æ–°è³‡æ–™ï¼‰ã€‚

### æ¨ç†æ™‚çš„å°ç¨±æ€§åˆ©ç”¨

AlphaGo åœ¨å¯¦éš›å°å¼ˆæ™‚ä¹Ÿåˆ©ç”¨å°ç¨±æ€§ï¼š

```python
def predict_with_symmetry(model, board):
    """
    åˆ©ç”¨å°ç¨±æ€§å¢å¼·é æ¸¬
    """
    policies = []
    values = []

    for sym_index in range(8):
        # è®Šæ›è¼¸å…¥
        aug_board = apply_symmetry(board, sym_index)

        # ç¥ç¶“ç¶²è·¯é æ¸¬
        policy, value = model.predict(aug_board)

        # å°‡ç­–ç•¥è®Šæ›å›åŸå§‹åº§æ¨™ç³»
        policy_2d = policy.reshape(19, 19)
        original_policy = inverse_symmetry_2d(policy_2d, sym_index)
        policies.append(original_policy.flatten())

        values.append(value)

    # å¹³å‡æ‰€æœ‰é æ¸¬
    avg_policy = np.mean(policies, axis=0)
    avg_value = np.mean(values)

    return avg_policy, avg_value
```

é€™ç¨®åšæ³•å¯ä»¥ç¨å¾®æé«˜é æ¸¬çš„æº–ç¢ºæ€§å’Œç©©å®šæ€§ã€‚

---

## æ£‹ç›¤è¡¨ç¤ºæ–¹æ³•ç¸½çµ

| æ–¹æ³• | ç”¨é€” | è¤‡é›œåº¦ | ç‰¹é» |
|------|------|--------|------|
| **äºŒç¶­é™£åˆ—** | åŸºæœ¬å„²å­˜ | O(361) ç©ºé–“ | ç°¡å–®ç›´è§€ |
| **Zobrist Hashing** | å±€é¢è­˜åˆ¥ | O(1) æŸ¥è©¢ | é«˜æ•ˆé›œæ¹Š |
| **Union-Find** | æ£‹ä¸²ç®¡ç† | O(Î±(n)) æ“ä½œ | è™•ç†é€£é€šæ€§ |
| **ç‰¹å¾µå¹³é¢** | ç¥ç¶“ç¶²è·¯è¼¸å…¥ | O(361Ã—å¹³é¢æ•¸) | ç·¨ç¢¼è±å¯Œè³‡è¨Š |
| **å°ç¨±æ€§è®Šæ›** | è³‡æ–™å¢å¼· | 8Ã— è³‡æ–™é‡ | å…è²»æ“´å¢ |

é€™äº›æŠ€è¡“ç›¸äº’é…åˆï¼Œæ§‹æˆäº†ç¾ä»£åœæ£‹ AI çš„åŸºç¤è¨­æ–½ã€‚

---

## å‹•ç•«å°æ‡‰

æœ¬æ–‡æ¶‰åŠçš„æ ¸å¿ƒæ¦‚å¿µèˆ‡å‹•ç•«ç·¨è™Ÿï¼š

| ç·¨è™Ÿ | æ¦‚å¿µ | ç‰©ç†/æ•¸å­¸å°æ‡‰ |
|------|------|--------------|
| ğŸ¬ A1 | äºŒç¶­é™£åˆ—è¡¨ç¤º | çŸ©é™£ã€ç¨€ç–è³‡æ–™ |
| ğŸ¬ A2 | Zobrist Hashing | é›œæ¹Šå‡½æ•¸ã€XOR é‹ç®— |
| ğŸ¬ A8 | ç‰¹å¾µå¹³é¢ç·¨ç¢¼ | å¼µé‡ã€å¤šé€šé“è¼¸å…¥ |
| ğŸ¬ A5 | å°ç¨±æ€§è™•ç† | ç¾¤è«–ã€äºŒé¢é«”ç¾¤ |

---

## å»¶ä¼¸é–±è®€

- **ä¸Šä¸€ç¯‡**ï¼š[å‚³çµ±æ–¹æ³•çš„æ¥µé™](../traditional-limits) â€” Minimax åˆ° MCTS
- **ä¸‹ä¸€ç¯‡**ï¼š[Policy Network è©³è§£](../policy-network) â€” ç¥ç¶“ç¶²è·¯å¦‚ä½•é æ¸¬è½å­
- **å¯¦ä½œç·´ç¿’**ï¼š[30 åˆ†é˜è·‘èµ·ç¬¬ä¸€å€‹åœæ£‹ AI](../../../hands-on/) â€” è¦ªè‡ªå‹•æ‰‹é«”é©—

---

## åƒè€ƒè³‡æ–™

1. Zobrist, A. L. (1970). "A new hashing method with application for game playing." ICCA journal.
2. Tarjan, R. E. (1975). "Efficiency of a Good But Not Linear Set Union Algorithm." Journal of the ACM, 22(2), 215-225.
3. Silver, D., et al. (2016). "Mastering the game of Go with deep neural networks and tree search." Nature, 529, 484-489. â€” AlphaGo 48 å€‹ç‰¹å¾µå¹³é¢
4. Silver, D., et al. (2017). "Mastering the game of Go without human knowledge." Nature, 550, 354-359. â€” AlphaGo Zero 17 å€‹ç‰¹å¾µå¹³é¢
