"use strict";(globalThis.webpackChunktemp_docusaurus=globalThis.webpackChunktemp_docusaurus||[]).push([[9047],{65707(e,n,a){a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>c,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"for-engineers/deep-dive/mcts-implementation","title":"Detail Implementasi MCTS","description":"Analisis mendalam implementasi Monte Carlo Tree Search, seleksi PUCT, dan teknik paralelisasi","source":"@site/i18n/id/docusaurus-plugin-content-docs/current/for-engineers/deep-dive/mcts-implementation.md","sourceDirName":"for-engineers/deep-dive","slug":"/for-engineers/deep-dive/mcts-implementation","permalink":"/id/docs/for-engineers/deep-dive/mcts-implementation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/for-engineers/deep-dive/mcts-implementation.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Detail Implementasi MCTS","description":"Analisis mendalam implementasi Monte Carlo Tree Search, seleksi PUCT, dan teknik paralelisasi"},"sidebar":"tutorialSidebar","previous":{"title":"Detail Arsitektur Neural Network","permalink":"/id/docs/for-engineers/deep-dive/neural-network"},"next":{"title":"Backend GPU dan Optimasi","permalink":"/id/docs/for-engineers/deep-dive/gpu-optimization"}}');var s=a(62615),l=a(30416);const t={sidebar_position:5,title:"Detail Implementasi MCTS",description:"Analisis mendalam implementasi Monte Carlo Tree Search, seleksi PUCT, dan teknik paralelisasi"},r="Detail Implementasi MCTS",o={},d=[{value:"Tinjauan Empat Langkah MCTS",id:"tinjauan-empat-langkah-mcts",level:2},{value:"Struktur Data Node",id:"struktur-data-node",level:2},{value:"Data Inti",id:"data-inti",level:3},{value:"Optimasi Memori",id:"optimasi-memori",level:3},{value:"Selection: Seleksi PUCT",id:"selection-seleksi-puct",level:2},{value:"Formula PUCT",id:"formula-puct",level:3},{value:"Penjelasan Parameter",id:"penjelasan-parameter",level:3},{value:"Implementasi",id:"implementasi",level:3},{value:"Keseimbangan Eksplorasi vs Eksploitasi",id:"keseimbangan-eksplorasi-vs-eksploitasi",level:3},{value:"Expansion: Ekspansi Node",id:"expansion-ekspansi-node",level:2},{value:"Kondisi Ekspansi",id:"kondisi-ekspansi",level:3},{value:"Filter Aksi Legal",id:"filter-aksi-legal",level:3},{value:"Evaluation: Evaluasi Neural Network",id:"evaluation-evaluasi-neural-network",level:2},{value:"Evaluasi Tunggal",id:"evaluasi-tunggal",level:3},{value:"Evaluasi Batch (Optimasi Kunci)",id:"evaluasi-batch-optimasi-kunci",level:3},{value:"Backpropagation: Update Balik",id:"backpropagation-update-balik",level:2},{value:"Backprop Dasar",id:"backprop-dasar",level:3},{value:"Pentingnya Perspektif Bergantian",id:"pentingnya-perspektif-bergantian",level:3},{value:"Paralelisasi: Virtual Loss",id:"paralelisasi-virtual-loss",level:2},{value:"Masalah",id:"masalah",level:3},{value:"Solusi: Virtual Loss",id:"solusi-virtual-loss",level:3},{value:"Efek",id:"efek",level:3},{value:"Implementasi Pencarian Lengkap",id:"implementasi-pencarian-lengkap",level:2},{value:"Teknik Lanjutan",id:"teknik-lanjutan",level:2},{value:"Noise Dirichlet",id:"noise-dirichlet",level:3},{value:"Parameter Temperatur",id:"parameter-temperatur",level:3},{value:"Penggunaan Ulang Pohon",id:"penggunaan-ulang-pohon",level:3},{value:"Ringkasan Optimasi Performa",id:"ringkasan-optimasi-performa",level:2},{value:"Bacaan Lanjutan",id:"bacaan-lanjutan",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"detail-implementasi-mcts",children:"Detail Implementasi MCTS"})}),"\n",(0,s.jsx)(n.p,{children:"Artikel ini menganalisis secara mendalam detail implementasi Monte Carlo Tree Search (MCTS) di KataGo, termasuk struktur data, strategi seleksi, dan teknik paralelisasi."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"tinjauan-empat-langkah-mcts",children:"Tinjauan Empat Langkah MCTS"}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart TB\n    S["1. Selection<br/>Seleksi: Turun pohon, gunakan PUCT untuk memilih node"]\n    E["2. Expansion<br/>Ekspansi: Mencapai leaf node, buat child node"]\n    V["3. Evaluation<br/>Evaluasi: Gunakan neural network untuk mengevaluasi leaf node"]\n    B["4. Backprop<br/>Backprop: Update statistik semua node di jalur"]\n    R["Ulangi ribuan kali, pilih aksi dengan kunjungan terbanyak"]\n\n    S --\x3e E --\x3e V --\x3e B --\x3e R'}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"struktur-data-node",children:"Struktur Data Node"}),"\n",(0,s.jsx)(n.h3,{id:"data-inti",children:"Data Inti"}),"\n",(0,s.jsx)(n.p,{children:"Setiap node MCTS perlu menyimpan:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class MCTSNode:\n    def __init__(self, state, parent=None, prior=0.0):\n        # Informasi dasar\n        self.state = state              # Status papan\n        self.parent = parent            # Node induk\n        self.children = {}              # Dictionary child node {action: node}\n        self.action = None              # Aksi untuk mencapai node ini\n\n        # Informasi statistik\n        self.visit_count = 0            # N(s): Jumlah kunjungan\n        self.value_sum = 0.0            # W(s): Total nilai\n        self.prior = prior              # P(s,a): Probabilitas prior\n\n        # Untuk pencarian paralel\n        self.virtual_loss = 0           # Virtual loss\n        self.is_expanded = False        # Apakah sudah diekspansi\n\n    @property\n    def value(self):\n        """Q(s) = W(s) / N(s)"""\n        if self.visit_count == 0:\n            return 0.0\n        return self.value_sum / self.visit_count\n'})}),"\n",(0,s.jsx)(n.h3,{id:"optimasi-memori",children:"Optimasi Memori"}),"\n",(0,s.jsx)(n.p,{children:"KataGo menggunakan berbagai teknik untuk mengurangi penggunaan memori:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Menggunakan array numpy bukan Python dict\nclass OptimizedNode:\n    __slots__ = ['visit_count', 'value_sum', 'prior', 'children_indices']\n\n    def __init__(self):\n        self.visit_count = np.int32(0)\n        self.value_sum = np.float32(0.0)\n        self.prior = np.float32(0.0)\n        self.children_indices = None  # Alokasi ditunda\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"selection-seleksi-puct",children:"Selection: Seleksi PUCT"}),"\n",(0,s.jsx)(n.h3,{id:"formula-puct",children:"Formula PUCT"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Skor Seleksi = Q(s,a) + U(s,a)\n\nDi mana:\nQ(s,a) = W(s,a) / N(s,a)              # Nilai rata-rata\nU(s,a) = c_puct \xd7 P(s,a) \xd7 \u221a(N(s)) / (1 + N(s,a))  # Komponen eksplorasi\n"})}),"\n",(0,s.jsx)(n.h3,{id:"penjelasan-parameter",children:"Penjelasan Parameter"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Simbol"}),(0,s.jsx)(n.th,{children:"Arti"}),(0,s.jsx)(n.th,{children:"Nilai Tipikal"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Q(s,a)"}),(0,s.jsx)(n.td,{children:"Nilai rata-rata aksi a"}),(0,s.jsx)(n.td,{children:"[-1, +1]"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"P(s,a)"}),(0,s.jsx)(n.td,{children:"Probabilitas prior dari neural network"}),(0,s.jsx)(n.td,{children:"[0, 1]"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"N(s)"}),(0,s.jsx)(n.td,{children:"Jumlah kunjungan node induk"}),(0,s.jsx)(n.td,{children:"Integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"N(s,a)"}),(0,s.jsx)(n.td,{children:"Jumlah kunjungan aksi a"}),(0,s.jsx)(n.td,{children:"Integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"c_puct"}),(0,s.jsx)(n.td,{children:"Konstanta eksplorasi"}),(0,s.jsx)(n.td,{children:"1.0 ~ 2.5"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"implementasi",children:"Implementasi"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def select_child(self, c_puct=1.5):\n    """Pilih child node dengan skor PUCT tertinggi"""\n    best_score = -float(\'inf\')\n    best_action = None\n    best_child = None\n\n    # Akar kuadrat jumlah kunjungan node induk\n    sqrt_parent_visits = math.sqrt(self.visit_count)\n\n    for action, child in self.children.items():\n        # Nilai Q (nilai rata-rata)\n        if child.visit_count > 0:\n            q_value = child.value_sum / child.visit_count\n        else:\n            q_value = 0.0\n\n        # Nilai U (komponen eksplorasi)\n        u_value = c_puct * child.prior * sqrt_parent_visits / (1 + child.visit_count)\n\n        # Total skor\n        score = q_value + u_value\n\n        if score > best_score:\n            best_score = score\n            best_action = action\n            best_child = child\n\n    return best_action, best_child\n'})}),"\n",(0,s.jsx)(n.h3,{id:"keseimbangan-eksplorasi-vs-eksploitasi",children:"Keseimbangan Eksplorasi vs Eksploitasi"}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph Early["Tahap Awal: N(s,a) kecil"]\n        E1["U(s,a) besar \u2192 Dominan eksplorasi"]\n        E2["Aksi dengan probabilitas prior tinggi dieksplorasi lebih dulu"]\n    end\n\n    subgraph Late["Tahap Akhir: N(s,a) besar"]\n        L1["U(s,a) kecil \u2192 Dominan eksploitasi"]\n        L2["Q(s,a) mendominasi, pilih aksi yang diketahui bagus"]\n    end\n\n    Early --\x3e Late'}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"expansion-ekspansi-node",children:"Expansion: Ekspansi Node"}),"\n",(0,s.jsx)(n.h3,{id:"kondisi-ekspansi",children:"Kondisi Ekspansi"}),"\n",(0,s.jsx)(n.p,{children:"Saat mencapai leaf node, gunakan neural network untuk ekspansi:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def expand(self, policy_probs, legal_moves):\n    """Ekspansi node, buat child node untuk semua aksi legal"""\n    for action in legal_moves:\n        if action not in self.children:\n            prior = policy_probs[action]  # Probabilitas dari neural network\n            child_state = self.state.play(action)\n            self.children[action] = MCTSNode(\n                state=child_state,\n                parent=self,\n                prior=prior\n            )\n\n    self.is_expanded = True\n'})}),"\n",(0,s.jsx)(n.h3,{id:"filter-aksi-legal",children:"Filter Aksi Legal"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def get_legal_moves(state):\n    """Dapatkan semua aksi legal"""\n    legal = []\n    for i in range(361):\n        x, y = i // 19, i % 19\n        if state.is_legal(x, y):\n            legal.append(i)\n\n    # Tambahkan pass\n    legal.append(361)\n\n    return legal\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"evaluation-evaluasi-neural-network",children:"Evaluation: Evaluasi Neural Network"}),"\n",(0,s.jsx)(n.h3,{id:"evaluasi-tunggal",children:"Evaluasi Tunggal"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def evaluate(self, state):\n    """Gunakan neural network untuk mengevaluasi posisi"""\n    # Encode fitur input\n    features = encode_state(state)  # (22, 19, 19)\n    features = torch.tensor(features).unsqueeze(0)  # (1, 22, 19, 19)\n\n    # Inferensi neural network\n    with torch.no_grad():\n        output = self.network(features)\n\n    policy = output[\'policy\'][0].numpy()  # (362,)\n    value = output[\'value\'][0].item()     # scalar\n\n    return policy, value\n'})}),"\n",(0,s.jsx)(n.h3,{id:"evaluasi-batch-optimasi-kunci",children:"Evaluasi Batch (Optimasi Kunci)"}),"\n",(0,s.jsx)(n.p,{children:"GPU paling efisien saat inferensi batch:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class BatchedEvaluator:\n    def __init__(self, network, batch_size=8):\n        self.network = network\n        self.batch_size = batch_size\n        self.pending = []  # List (state, callback) yang menunggu evaluasi\n\n    def request_evaluation(self, state, callback):\n        """Minta evaluasi, otomatis eksekusi saat batch penuh"""\n        self.pending.append((state, callback))\n\n        if len(self.pending) >= self.batch_size:\n            self.flush()\n\n    def flush(self):\n        """Eksekusi evaluasi batch"""\n        if not self.pending:\n            return\n\n        # Siapkan input batch\n        states = [s for s, _ in self.pending]\n        features = torch.stack([encode_state(s) for s in states])\n\n        # Inferensi batch\n        with torch.no_grad():\n            outputs = self.network(features)\n\n        # Callback hasil\n        for i, (_, callback) in enumerate(self.pending):\n            policy = outputs[\'policy\'][i].numpy()\n            value = outputs[\'value\'][i].item()\n            callback(policy, value)\n\n        self.pending.clear()\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"backpropagation-update-balik",children:"Backpropagation: Update Balik"}),"\n",(0,s.jsx)(n.h3,{id:"backprop-dasar",children:"Backprop Dasar"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def backpropagate(self, value):\n    """Backprop dari leaf node ke root node, update informasi statistik"""\n    node = self\n\n    while node is not None:\n        node.visit_count += 1\n        node.value_sum += value\n\n        # Perspektif bergantian: nilai lawan adalah kebalikannya\n        value = -value\n\n        node = node.parent\n'})}),"\n",(0,s.jsx)(n.h3,{id:"pentingnya-perspektif-bergantian",children:"Pentingnya Perspektif Bergantian"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Perspektif Hitam: value = +0.6 (Hitam unggul)\n\nJalur backprop:\nLeaf node (giliran Hitam): value_sum += +0.6\n    \u2191\nParent node (giliran Putih): value_sum += -0.6  \u2190 Tidak menguntungkan untuk Putih\n    \u2191\nGrandparent node (giliran Hitam): value_sum += +0.6\n    \u2191\n...\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"paralelisasi-virtual-loss",children:"Paralelisasi: Virtual Loss"}),"\n",(0,s.jsx)(n.h3,{id:"masalah",children:"Masalah"}),"\n",(0,s.jsx)(n.p,{children:"Saat multi-thread mencari secara bersamaan, mungkin semua memilih node yang sama:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Thread 1: Pilih node A (Q=0.6, N=100)\nThread 2: Pilih node A (Q=0.6, N=100) \u2190 Duplikat!\nThread 3: Pilih node A (Q=0.6, N=100) \u2190 Duplikat!\n"})}),"\n",(0,s.jsx)(n.h3,{id:"solusi-virtual-loss",children:"Solusi: Virtual Loss"}),"\n",(0,s.jsx)(n.p,{children:'Saat memilih node, tambahkan "virtual loss" lebih dulu, membuat thread lain tidak mau memilihnya:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'VIRTUAL_LOSS = 3  # Nilai virtual loss\n\ndef select_with_virtual_loss(self):\n    """Seleksi dengan virtual loss"""\n    action, child = self.select_child()\n\n    # Tambahkan virtual loss\n    child.visit_count += VIRTUAL_LOSS\n    child.value_sum -= VIRTUAL_LOSS  # Pura-pura kalah\n\n    return action, child\n\ndef backpropagate_with_virtual_loss(self, value):\n    """Hapus virtual loss saat backprop"""\n    node = self\n\n    while node is not None:\n        # Hapus virtual loss\n        node.visit_count -= VIRTUAL_LOSS\n        node.value_sum += VIRTUAL_LOSS\n\n        # Update normal\n        node.visit_count += 1\n        node.value_sum += value\n\n        value = -value\n        node = node.parent\n'})}),"\n",(0,s.jsx)(n.h3,{id:"efek",children:"Efek"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Thread 1: Pilih node A, tambahkan virtual loss\n         Nilai Q node A turun sementara\n\nThread 2: Pilih node B (karena A terlihat lebih buruk)\n\nThread 3: Pilih node C\n\n\u2192 Thread berbeda mengeksplorasi cabang berbeda, meningkatkan efisiensi\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"implementasi-pencarian-lengkap",children:"Implementasi Pencarian Lengkap"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class MCTS:\n    def __init__(self, network, c_puct=1.5, num_simulations=800):\n        self.network = network\n        self.c_puct = c_puct\n        self.num_simulations = num_simulations\n        self.evaluator = BatchedEvaluator(network)\n\n    def search(self, root_state):\n        """Eksekusi pencarian MCTS"""\n        root = MCTSNode(root_state)\n\n        # Ekspansi root node\n        policy, value = self.evaluate(root_state)\n        legal_moves = get_legal_moves(root_state)\n        root.expand(policy, legal_moves)\n\n        # Eksekusi simulasi\n        for _ in range(self.num_simulations):\n            node = root\n            path = [node]\n\n            # Selection: Turun pohon\n            while node.is_expanded and node.children:\n                action, node = node.select_child(self.c_puct)\n                path.append(node)\n\n            # Expansion + Evaluation\n            if not node.is_expanded:\n                policy, value = self.evaluate(node.state)\n                legal_moves = get_legal_moves(node.state)\n\n                if legal_moves:\n                    node.expand(policy, legal_moves)\n\n            # Backpropagation\n            for n in reversed(path):\n                n.visit_count += 1\n                n.value_sum += value\n                value = -value\n\n        # Pilih aksi dengan kunjungan terbanyak\n        best_action = max(root.children.items(),\n                         key=lambda x: x[1].visit_count)[0]\n\n        return best_action\n\n    def evaluate(self, state):\n        features = encode_state(state)\n        features = torch.tensor(features).unsqueeze(0)\n\n        with torch.no_grad():\n            output = self.network(features)\n\n        return output[\'policy\'][0].numpy(), output[\'value\'][0].item()\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"teknik-lanjutan",children:"Teknik Lanjutan"}),"\n",(0,s.jsx)(n.h3,{id:"noise-dirichlet",children:"Noise Dirichlet"}),"\n",(0,s.jsx)(n.p,{children:"Tambahkan noise di root node saat pelatihan untuk meningkatkan eksplorasi:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def add_dirichlet_noise(root, alpha=0.03, epsilon=0.25):\n    """Tambahkan noise Dirichlet di root node"""\n    noise = np.random.dirichlet([alpha] * len(root.children))\n\n    for i, child in enumerate(root.children.values()):\n        child.prior = (1 - epsilon) * child.prior + epsilon * noise[i]\n'})}),"\n",(0,s.jsx)(n.h3,{id:"parameter-temperatur",children:"Parameter Temperatur"}),"\n",(0,s.jsx)(n.p,{children:"Mengontrol keacakan pemilihan aksi:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def select_action_with_temperature(root, temperature=1.0):\n    """Pilih aksi berdasarkan jumlah kunjungan dan temperatur"""\n    visits = np.array([c.visit_count for c in root.children.values()])\n    actions = list(root.children.keys())\n\n    if temperature == 0:\n        # Pilihan greedy\n        return actions[np.argmax(visits)]\n    else:\n        # Pilih berdasarkan distribusi probabilitas dari jumlah kunjungan\n        probs = visits ** (1 / temperature)\n        probs = probs / probs.sum()\n        return np.random.choice(actions, p=probs)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"penggunaan-ulang-pohon",children:"Penggunaan Ulang Pohon"}),"\n",(0,s.jsx)(n.p,{children:"Langkah baru bisa menggunakan ulang pohon pencarian sebelumnya:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def reuse_tree(root, action):\n    """Gunakan ulang subtree"""\n    if action in root.children:\n        new_root = root.children[action]\n        new_root.parent = None\n        return new_root\n    else:\n        return None  # Perlu buat pohon baru\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"ringkasan-optimasi-performa",children:"Ringkasan Optimasi Performa"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Teknik"}),(0,s.jsx)(n.th,{children:"Efek"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Evaluasi Batch"})}),(0,s.jsx)(n.td,{children:"Utilisasi GPU dari 10% \u2192 80%+"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Virtual Loss"})}),(0,s.jsx)(n.td,{children:"Efisiensi multi-thread meningkat 3-5x"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Penggunaan Ulang Pohon"})}),(0,s.jsx)(n.td,{children:"Kurangi cold start, hemat 30%+ komputasi"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Memory Pool"})}),(0,s.jsx)(n.td,{children:"Kurangi overhead alokasi memori"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"bacaan-lanjutan",children:"Bacaan Lanjutan"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"../neural-network",children:"Detail Arsitektur Neural Network"})," \u2014 Sumber fungsi evaluasi"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"../gpu-optimization",children:"Backend GPU dan Optimasi"})," \u2014 Optimasi hardware untuk inferensi batch"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"../papers",children:"Panduan Paper Kunci"})," \u2014 Dasar teori formula PUCT"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},30416(e,n,a){a.d(n,{R:()=>t,x:()=>r});var i=a(59471);const s={},l=i.createContext(s);function t(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);