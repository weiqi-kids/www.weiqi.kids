"use strict";(globalThis.webpackChunktemp_docusaurus=globalThis.webpackChunktemp_docusaurus||[]).push([[4371],{70998(e,a,n){n.r(a),n.d(a,{assets:()=>d,contentTitle:()=>t,default:()=>o,frontMatter:()=>s,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"alphago/dual-head-resnet","title":"Dual-Head Network dan Residual Network","description":"Analisis mendalam arsitektur neural network AlphaGo Zero - Shared backbone, Policy Head, Value Head, dan 40-layer ResNet","source":"@site/i18n/id/docusaurus-plugin-content-docs/current/alphago/17-dual-head-resnet.mdx","sourceDirName":"alphago","slug":"/alphago/dual-head-resnet","permalink":"/id/docs/alphago/dual-head-resnet","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/alphago/17-dual-head-resnet.mdx","tags":[],"version":"current","sidebarPosition":18,"frontMatter":{"sidebar_position":18,"title":"Dual-Head Network dan Residual Network","description":"Analisis mendalam arsitektur neural network AlphaGo Zero - Shared backbone, Policy Head, Value Head, dan 40-layer ResNet","keywords":["dual-head network","residual network","ResNet","Policy Head","Value Head","deep learning","arsitektur neural network"]},"sidebar":"tutorialSidebar","previous":{"title":"Ikhtisar AlphaGo Zero","permalink":"/id/docs/alphago/alphago-zero"},"next":{"title":"Proses Pelatihan dari Nol","permalink":"/id/docs/alphago/training-from-scratch"}}');var l=n(62615),r=n(30416);const s={sidebar_position:18,title:"Dual-Head Network dan Residual Network",description:"Analisis mendalam arsitektur neural network AlphaGo Zero - Shared backbone, Policy Head, Value Head, dan 40-layer ResNet",keywords:["dual-head network","residual network","ResNet","Policy Head","Value Head","deep learning","arsitektur neural network"]},t="Dual-Head Network dan Residual Network",d={},h=[{value:"Desain Dual-Head Network",id:"desain-dual-head-network",level:2},{value:"Arsitektur Keseluruhan",id:"arsitektur-keseluruhan",level:3},{value:"Shared Backbone",id:"shared-backbone",level:3},{value:"Detail Arsitektur",id:"detail-arsitektur",level:4},{value:"Representasi Matematika",id:"representasi-matematika",level:4},{value:"Policy Head (Head Strategi)",id:"policy-head-head-strategi",level:3},{value:"Detail Arsitektur",id:"detail-arsitektur-1",level:4},{value:"Representasi Matematika",id:"representasi-matematika-1",level:4},{value:"Value Head (Head Nilai)",id:"value-head-head-nilai",level:3},{value:"Detail Arsitektur",id:"detail-arsitektur-2",level:4},{value:"Representasi Matematika",id:"representasi-matematika-2",level:4},{value:"Mengapa Perlu Shared Backbone?",id:"mengapa-perlu-shared-backbone",level:2},{value:"Pemahaman Intuitif",id:"pemahaman-intuitif",level:3},{value:"Perspektif Multi-task Learning",id:"perspektif-multi-task-learning",level:3},{value:"1. Efek Regularisasi",id:"1-efek-regularisasi",level:4},{value:"2. Efisiensi Data",id:"2-efisiensi-data",level:4},{value:"3. Sinyal Gradien yang Kaya",id:"3-sinyal-gradien-yang-kaya",level:4},{value:"Bukti Eksperimental",id:"bukti-eksperimental",level:3},{value:"Prinsip Residual Network",id:"prinsip-residual-network",level:2},{value:"Dilema Deep Network",id:"dilema-deep-network",level:3},{value:"Desain Residual Block",id:"desain-residual-block",level:3},{value:"Representasi Matematika",id:"representasi-matematika-3",level:4},{value:"Mengapa Residual Connection Efektif?",id:"mengapa-residual-connection-efektif",level:3},{value:"1. Highway Gradien",id:"1-highway-gradien",level:4},{value:"2. Identity Mapping Lebih Mudah Dipelajari",id:"2-identity-mapping-lebih-mudah-dipelajari",level:4},{value:"3. Efek Ensemble",id:"3-efek-ensemble",level:4},{value:"Terobosan ResNet di ImageNet",id:"terobosan-resnet-di-imagenet",level:3},{value:"40-Layer ResNet AlphaGo Zero",id:"40-layer-resnet-alphago-zero",level:2},{value:"Mengapa Memilih 40 Layer?",id:"mengapa-memilih-40-layer",level:3},{value:"Konfigurasi Konkret",id:"konfigurasi-konkret",level:3},{value:"Estimasi Jumlah Parameter",id:"estimasi-jumlah-parameter",level:4},{value:"Peran Batch Normalization",id:"peran-batch-normalization",level:3},{value:"1. Normalisasi Nilai Aktivasi",id:"1-normalisasi-nilai-aktivasi",level:4},{value:"2. Mengurangi Internal Covariate Shift",id:"2-mengurangi-internal-covariate-shift",level:4},{value:"3. Efek Regularisasi",id:"3-efek-regularisasi",level:4},{value:"Perbandingan dengan Arsitektur Lain",id:"perbandingan-dengan-arsitektur-lain",level:2},{value:"vs. CNN AlphaGo Original",id:"vs-cnn-alphago-original",level:3},{value:"vs. Network Gaya VGG",id:"vs-network-gaya-vgg",level:3},{value:"vs. Inception / GoogLeNet",id:"vs-inception--googlenet",level:3},{value:"vs. Transformer",id:"vs-transformer",level:3},{value:"Analisis Mendalam Pilihan Desain",id:"analisis-mendalam-pilihan-desain",level:2},{value:"Mengapa Menggunakan Konvolusi 3x3?",id:"mengapa-menggunakan-konvolusi-3x3",level:3},{value:"Mengapa Menggunakan 256 Channel?",id:"mengapa-menggunakan-256-channel",level:3},{value:"Mengapa Policy Head Menggunakan Softmax, Value Head Menggunakan Tanh?",id:"mengapa-policy-head-menggunakan-softmax-value-head-menggunakan-tanh",level:3},{value:"Policy Head: Softmax",id:"policy-head-softmax",level:4},{value:"Value Head: Tanh",id:"value-head-tanh",level:4},{value:"Detail Pelatihan",id:"detail-pelatihan",level:2},{value:"Loss Function",id:"loss-function",level:3},{value:"Policy Loss",id:"policy-loss",level:4},{value:"Value Loss",id:"value-loss",level:4},{value:"Regularization Loss",id:"regularization-loss",level:4},{value:"Konfigurasi Optimizer",id:"konfigurasi-optimizer",level:3},{value:"Data Augmentation",id:"data-augmentation",level:3},{value:"Pertimbangan Implementasi",id:"pertimbangan-implementasi",level:2},{value:"Optimisasi Memori",id:"optimisasi-memori",level:3},{value:"Optimisasi Inferensi",id:"optimisasi-inferensi",level:3},{value:"Quantization dan Compression",id:"quantization-dan-compression",level:3},{value:"Korespondensi Animasi",id:"korespondensi-animasi",level:2},{value:"Bacaan Lanjutan",id:"bacaan-lanjutan",level:2},{value:"Referensi",id:"referensi",level:2}];function c(e){const a={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(a.header,{children:(0,l.jsx)(a.h1,{id:"dual-head-network-dan-residual-network",children:"Dual-Head Network dan Residual Network"})}),"\n",(0,l.jsxs)(a.p,{children:["Salah satu inovasi arsitektur terpenting AlphaGo Zero adalah menggunakan ",(0,l.jsx)(a.strong,{children:"Dual-Head Network"})," menggantikan desain dual network AlphaGo original. Perubahan yang tampak sederhana ini membawa peningkatan performa signifikan dan proses pembelajaran yang lebih elegan."]}),"\n",(0,l.jsx)(a.p,{children:"Artikel ini akan menganalisis secara mendalam prinsip desain arsitektur ini, dasar matematika, dan mengapa ia sangat efektif."}),"\n",(0,l.jsx)(a.hr,{}),"\n",(0,l.jsx)(a.h2,{id:"desain-dual-head-network",children:"Desain Dual-Head Network"}),"\n",(0,l.jsx)(a.h3,{id:"arsitektur-keseluruhan",children:"Arsitektur Keseluruhan"}),"\n",(0,l.jsx)(a.p,{children:"Neural network AlphaGo Zero bisa dibagi menjadi tiga bagian:"}),"\n",(0,l.jsx)(a.mermaid,{value:'flowchart TB\n    Input["Input (17 x 19 x 19)"]\n    Backbone["Shared Backbone (ResNet)<br/>40 residual block, 256 channel"]\n    Policy["Policy Head<br/>(Head Strategi)"]\n    Value["Value Head<br/>(Head Nilai)"]\n    POut["Distribusi prob.<br/>19x19 + 1 Pass"]\n    VOut["Win rate [-1, 1]"]\n\n    Input --\x3e Backbone\n    Backbone --\x3e Policy\n    Backbone --\x3e Value\n    Policy --\x3e POut\n    Value --\x3e VOut'}),"\n",(0,l.jsx)(a.p,{children:"Mari kita analisis setiap bagian satu per satu."}),"\n",(0,l.jsx)(a.h3,{id:"shared-backbone",children:"Shared Backbone"}),"\n",(0,l.jsxs)(a.p,{children:["Shared backbone adalah ",(0,l.jsx)(a.strong,{children:"Residual Network (ResNet)"})," yang dalam, bertanggung jawab mengekstrak fitur dari state papan."]}),"\n",(0,l.jsx)(a.h4,{id:"detail-arsitektur",children:"Detail Arsitektur"}),"\n",(0,l.jsxs)(a.table,{children:[(0,l.jsx)(a.thead,{children:(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.th,{children:"Komponen"}),(0,l.jsx)(a.th,{children:"Spesifikasi"})]})}),(0,l.jsxs)(a.tbody,{children:[(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Layer input"}),(0,l.jsx)(a.td,{children:"Konvolusi 3x3, 256 channel"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Residual block"}),(0,l.jsx)(a.td,{children:"40 (atau 20 versi ringkas)"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Setiap residual block"}),(0,l.jsx)(a.td,{children:"2 layer konvolusi 3x3, 256 channel"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Fungsi aktivasi"}),(0,l.jsx)(a.td,{children:"ReLU"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Normalisasi"}),(0,l.jsx)(a.td,{children:"Batch Normalization"})]})]})]}),"\n",(0,l.jsx)(a.h4,{id:"representasi-matematika",children:"Representasi Matematika"}),"\n",(0,l.jsx)(a.p,{children:"Misalkan input adalah x (dimensi 17 x 19 x 19), output shared backbone adalah:"}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{children:"f(x) = ResNet_40(Conv_3x3(x))\n"})}),"\n",(0,l.jsx)(a.p,{children:"Di mana f(x) (dimensi 256 x 19 x 19) adalah representasi fitur dimensi tinggi."}),"\n",(0,l.jsx)(a.h3,{id:"policy-head-head-strategi",children:"Policy Head (Head Strategi)"}),"\n",(0,l.jsx)(a.p,{children:"Policy Head bertanggung jawab memprediksi probabilitas langkah untuk setiap posisi."}),"\n",(0,l.jsx)(a.h4,{id:"detail-arsitektur-1",children:"Detail Arsitektur"}),"\n",(0,l.jsx)(a.mermaid,{value:'flowchart TB\n    Input["Output Shared Backbone (256 x 19 x 19)"]\n    Conv["Konvolusi 1x1 (2 channel)"]\n    BN["Batch Normalization"]\n    ReLU["ReLU"]\n    Flat["Flatten (2 x 19 x 19 = 722)"]\n    FC["Fully connected layer (362)"]\n    Soft["Softmax"]\n    Out["Output: 362 probabilitas (361 posisi + Pass)"]\n\n    Input --\x3e Conv --\x3e BN --\x3e ReLU --\x3e Flat --\x3e FC --\x3e Soft --\x3e Out'}),"\n",(0,l.jsx)(a.h4,{id:"representasi-matematika-1",children:"Representasi Matematika"}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{children:"\u03c0 = Softmax(FC(Flatten(ReLU(BN(Conv_1x1(f(x)))))))\n"})}),"\n",(0,l.jsx)(a.p,{children:"Output \u03c0 adalah vektor 362 dimensi, memenuhi semua elemen non-negatif dan jumlahnya 1."}),"\n",(0,l.jsx)(a.h3,{id:"value-head-head-nilai",children:"Value Head (Head Nilai)"}),"\n",(0,l.jsx)(a.p,{children:"Value Head bertanggung jawab memprediksi win rate posisi saat ini."}),"\n",(0,l.jsx)(a.h4,{id:"detail-arsitektur-2",children:"Detail Arsitektur"}),"\n",(0,l.jsx)(a.mermaid,{value:'flowchart TB\n    Input["Output Shared Backbone (256 x 19 x 19)"]\n    Conv["Konvolusi 1x1 (1 channel)"]\n    BN["Batch Normalization"]\n    R1["ReLU"]\n    Flat["Flatten (1 x 19 x 19 = 361)"]\n    FC1["Fully connected layer (256)"]\n    R2["ReLU"]\n    FC2["Fully connected layer (1)"]\n    Tanh["Tanh"]\n    Out["Output: Win rate [-1, 1]"]\n\n    Input --\x3e Conv --\x3e BN --\x3e R1 --\x3e Flat --\x3e FC1 --\x3e R2 --\x3e FC2 --\x3e Tanh --\x3e Out'}),"\n",(0,l.jsx)(a.h4,{id:"representasi-matematika-2",children:"Representasi Matematika"}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{children:"v = Tanh(FC_1(ReLU(FC_2(Flatten(ReLU(BN(Conv_1x1(f(x)))))))))\n"})}),"\n",(0,l.jsx)(a.p,{children:"Output v dalam range [-1, 1]:"}),"\n",(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsx)(a.li,{children:"v = 1: Pemain saat ini pasti menang"}),"\n",(0,l.jsx)(a.li,{children:"v = -1: Pemain saat ini pasti kalah"}),"\n",(0,l.jsx)(a.li,{children:"v = 0: Seimbang"}),"\n"]}),"\n",(0,l.jsx)(a.hr,{}),"\n",(0,l.jsx)(a.h2,{id:"mengapa-perlu-shared-backbone",children:"Mengapa Perlu Shared Backbone?"}),"\n",(0,l.jsx)(a.h3,{id:"pemahaman-intuitif",children:"Pemahaman Intuitif"}),"\n",(0,l.jsx)(a.p,{children:'"Langkah berikutnya harus dimainkan di mana" (Policy) dan "siapa yang akan menang" (Value) kedua masalah ini sebenarnya membutuhkan pemahaman pola papan yang sama:'}),"\n",(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Bentuk batu"}),": Bentuk mana yang bagus, mana yang buruk"]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Pengaruh"}),": Sisi mana lebih besar, area mana masih ada ruang"]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Hidup-mati"}),": Kelompok batu mana yang sudah hidup, mana yang masih dalam ko"]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Pertempuran"}),": Di mana ada serangan, bagaimana hasil lokal"]}),"\n"]}),"\n",(0,l.jsx)(a.p,{children:"Jika menggunakan dua network independen, fitur-fitur ini perlu dipelajari dua kali. Shared backbone membuat fitur-fitur dasar ini hanya perlu dipelajari sekali, kedua tugas bisa menggunakannya."}),"\n",(0,l.jsx)(a.h3,{id:"perspektif-multi-task-learning",children:"Perspektif Multi-task Learning"}),"\n",(0,l.jsxs)(a.p,{children:["Dari sudut pandang machine learning, ini adalah ",(0,l.jsx)(a.strong,{children:"Multi-task Learning"}),":"]}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{children:"L = L_policy + L_value\n"})}),"\n",(0,l.jsx)(a.p,{children:"Kedua tugas berbagi representasi dasar, ini membawa beberapa keuntungan:"}),"\n",(0,l.jsx)(a.h4,{id:"1-efek-regularisasi",children:"1. Efek Regularisasi"}),"\n",(0,l.jsx)(a.p,{children:"Berbagi parameter setara dengan regularisasi implisit. Jika suatu fitur hanya berguna untuk Policy tapi tidak untuk Value (atau sebaliknya), lebih sulit untuk diperbesar berlebihan."}),"\n",(0,l.jsx)(a.p,{children:"Jumlah parameter efektif lebih kecil dari jumlah parameter dua network independen."}),"\n",(0,l.jsx)(a.h4,{id:"2-efisiensi-data",children:"2. Efisiensi Data"}),"\n",(0,l.jsx)(a.p,{children:"Setiap permainan secara bersamaan menghasilkan label Policy (probabilitas pencarian MCTS) dan label Value (hasil akhir menang/kalah). Shared backbone membuat kedua label digunakan untuk melatih fitur bersama, meningkatkan efisiensi pemanfaatan data."}),"\n",(0,l.jsx)(a.h4,{id:"3-sinyal-gradien-yang-kaya",children:"3. Sinyal Gradien yang Kaya"}),"\n",(0,l.jsx)(a.p,{children:"Gradien dari kedua tugas mengalir ke shared backbone:"}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{children:"\u2202L/\u2202\u03b8_shared = \u2202L_policy/\u2202\u03b8_shared + \u2202L_value/\u2202\u03b8_shared\n"})}),"\n",(0,l.jsx)(a.p,{children:"Ini menyediakan sinyal supervisi yang lebih kaya, membuat fitur bersama lebih robust."}),"\n",(0,l.jsx)(a.h3,{id:"bukti-eksperimental",children:"Bukti Eksperimental"}),"\n",(0,l.jsx)(a.p,{children:"Eksperimen ablasi DeepMind menunjukkan, performa dual-head network secara signifikan lebih baik dari dual network terpisah:"}),"\n",(0,l.jsxs)(a.table,{children:[(0,l.jsx)(a.thead,{children:(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.th,{children:"Konfigurasi"}),(0,l.jsx)(a.th,{children:"Rating ELO"}),(0,l.jsx)(a.th,{children:"Selisih Relatif"})]})}),(0,l.jsxs)(a.tbody,{children:[(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Network Policy + Value terpisah"}),(0,l.jsx)(a.td,{children:"Baseline"}),(0,l.jsx)(a.td,{children:"-"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Dual-head network (shared backbone)"}),(0,l.jsx)(a.td,{children:"+300 ELO"}),(0,l.jsx)(a.td,{children:"~65% selisih win rate"})]})]})]}),"\n",(0,l.jsx)(a.p,{children:"Selisih 300 ELO berarti dual-head network memiliki sekitar 65% win rate terhadap network terpisah. Ini adalah peningkatan yang signifikan."}),"\n",(0,l.jsx)(a.hr,{}),"\n",(0,l.jsx)(a.h2,{id:"prinsip-residual-network",children:"Prinsip Residual Network"}),"\n",(0,l.jsx)(a.h3,{id:"dilema-deep-network",children:"Dilema Deep Network"}),"\n",(0,l.jsx)(a.p,{children:"Sebelum ResNet ditemukan, deep neural network menghadapi paradoks:"}),"\n",(0,l.jsxs)(a.blockquote,{children:["\n",(0,l.jsx)(a.p,{children:"Secara teori, network lebih dalam seharusnya setidaknya sama baiknya dengan network dangkal (worst case, layer tambahan bisa mempelajari identity mapping). Tapi kenyataannya, network lebih dalam seringkali berkinerja lebih buruk."}),"\n"]}),"\n",(0,l.jsxs)(a.p,{children:["Inilah ",(0,l.jsx)(a.strong,{children:"Masalah Degradasi (Degradation Problem)"}),":"]}),"\n",(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsx)(a.li,{children:"Training error meningkat dengan kedalaman (bukan overfitting, tapi kesulitan optimisasi)"}),"\n",(0,l.jsx)(a.li,{children:"Gradien menghilang secara bertahap saat backpropagation (Vanishing Gradient)"}),"\n",(0,l.jsx)(a.li,{children:"Parameter layer dalam hampir tidak bisa diupdate secara efektif"}),"\n"]}),"\n",(0,l.jsx)(a.h3,{id:"desain-residual-block",children:"Desain Residual Block"}),"\n",(0,l.jsxs)(a.p,{children:["He Kaiming et al. pada 2015 mengajukan solusi simpel namun elegan: ",(0,l.jsx)(a.strong,{children:"Skip Connection (Residual Connection)"}),"."]}),"\n",(0,l.jsx)(a.mermaid,{value:'flowchart TB\n    Input["Input x"]\n    Conv1["Conv layer"]\n    BN1["BN + ReLU"]\n    Conv2["Conv layer"]\n    BN2["BN"]\n    Add["+ (F(x) + x)"]\n    ReLU["ReLU"]\n    Output["Output x + F(x)"]\n\n    Input --\x3e Conv1 --\x3e BN1 --\x3e Conv2 --\x3e BN2 --\x3e Add\n    Input -.->|skip connection| Add\n    Add --\x3e ReLU --\x3e Output'}),"\n",(0,l.jsx)(a.h4,{id:"representasi-matematika-3",children:"Representasi Matematika"}),"\n",(0,l.jsx)(a.p,{children:"Network tradisional: Belajar target mapping H(x)"}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{children:"y = H(x)\n"})}),"\n",(0,l.jsxs)(a.p,{children:["Residual network: Belajar ",(0,l.jsx)(a.strong,{children:"residual mapping"})," F(x) = H(x) - x"]}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{children:"y = F(x) + x\n"})}),"\n",(0,l.jsx)(a.h3,{id:"mengapa-residual-connection-efektif",children:"Mengapa Residual Connection Efektif?"}),"\n",(0,l.jsx)(a.h4,{id:"1-highway-gradien",children:"1. Highway Gradien"}),"\n",(0,l.jsx)(a.p,{children:"Pertimbangkan gradien saat backpropagation:"}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{children:"\u2202L/\u2202x = \u2202L/\u2202y \xd7 \u2202y/\u2202x = \u2202L/\u2202y \xd7 (1 + \u2202F(x)/\u2202x)\n"})}),"\n",(0,l.jsxs)(a.p,{children:["Kuncinya adalah ",(0,l.jsx)(a.strong,{children:"+1"})," itu. Bahkan jika \u2202F(x)/\u2202x sangat kecil atau nol, gradien tetap bisa langsung diteruskan kembali melalui +1."]}),"\n",(0,l.jsx)(a.p,{children:'Ini seperti membangun "highway gradien", membiarkan gradien mengalir tanpa hambatan dari output layer kembali ke input layer.'}),"\n",(0,l.jsx)(a.h4,{id:"2-identity-mapping-lebih-mudah-dipelajari",children:"2. Identity Mapping Lebih Mudah Dipelajari"}),"\n",(0,l.jsx)(a.p,{children:"Jika solusi optimal mendekati identity mapping (H(x) mendekati x), maka:"}),"\n",(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsx)(a.li,{children:"Network tradisional: Perlu belajar H(x) = x, mungkin sulit"}),"\n",(0,l.jsx)(a.li,{children:"Residual network: Hanya perlu belajar F(x) mendekati 0, relatif mudah"}),"\n"]}),"\n",(0,l.jsx)(a.p,{children:"Menginisialisasi weight ke nol atau mendekati nol, residual block secara natural menuju identity mapping."}),"\n",(0,l.jsx)(a.h4,{id:"3-efek-ensemble",children:"3. Efek Ensemble"}),"\n",(0,l.jsxs)(a.p,{children:["Deep ResNet bisa dilihat sebagai ",(0,l.jsx)(a.strong,{children:"ensemble implisit"})," dari banyak shallow network. Jika ada n residual block, informasi bisa mengalir melalui 2^n jalur berbeda."]}),"\n",(0,l.jsx)(a.p,{children:"Efek ensemble ini meningkatkan robustness model."}),"\n",(0,l.jsx)(a.h3,{id:"terobosan-resnet-di-imagenet",children:"Terobosan ResNet di ImageNet"}),"\n",(0,l.jsx)(a.p,{children:"ResNet meraih hasil menakjubkan di kompetisi ImageNet 2015:"}),"\n",(0,l.jsxs)(a.table,{children:[(0,l.jsx)(a.thead,{children:(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.th,{children:"Kedalaman"}),(0,l.jsx)(a.th,{children:"Top-5 Error Rate"})]})}),(0,l.jsxs)(a.tbody,{children:[(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"VGG-19 (tanpa residual)"}),(0,l.jsx)(a.td,{children:"7.3%"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"ResNet-34"}),(0,l.jsx)(a.td,{children:"5.7%"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"ResNet-152"}),(0,l.jsx)(a.td,{children:"4.5%"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Level manusia"}),(0,l.jsx)(a.td,{children:"~5.1%"})]})]})]}),"\n",(0,l.jsxs)(a.p,{children:["ResNet ",(0,l.jsx)(a.strong,{children:"152 layer"})," tidak hanya bisa dilatih, tapi juga jauh lebih baik dari VGG 19 layer. Ini membuktikan residual connection memang menyelesaikan masalah pelatihan deep network."]}),"\n",(0,l.jsx)(a.hr,{}),"\n",(0,l.jsx)(a.h2,{id:"40-layer-resnet-alphago-zero",children:"40-Layer ResNet AlphaGo Zero"}),"\n",(0,l.jsx)(a.h3,{id:"mengapa-memilih-40-layer",children:"Mengapa Memilih 40 Layer?"}),"\n",(0,l.jsx)(a.p,{children:"DeepMind menguji ResNet dengan kedalaman berbeda:"}),"\n",(0,l.jsxs)(a.table,{children:[(0,l.jsx)(a.thead,{children:(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.th,{children:"Jumlah Residual Block"}),(0,l.jsx)(a.th,{children:"Total Layer"}),(0,l.jsx)(a.th,{children:"Rating ELO"})]})}),(0,l.jsxs)(a.tbody,{children:[(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"5"}),(0,l.jsx)(a.td,{children:"11"}),(0,l.jsx)(a.td,{children:"Baseline"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"10"}),(0,l.jsx)(a.td,{children:"21"}),(0,l.jsx)(a.td,{children:"+200"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"20"}),(0,l.jsx)(a.td,{children:"41"}),(0,l.jsx)(a.td,{children:"+400"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"40"}),(0,l.jsx)(a.td,{children:"81"}),(0,l.jsx)(a.td,{children:"+500"})]})]})]}),"\n",(0,l.jsx)(a.p,{children:"Network lebih dalam memang lebih kuat, tapi diminishing returns. AlphaGo Zero menggunakan 20 atau 40 residual block:"}),"\n",(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"AlphaGo Zero (versi paper)"}),": 40 residual block, 256 channel"]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Versi ringkas"}),": 20 residual block, 256 channel"]}),"\n"]}),"\n",(0,l.jsx)(a.p,{children:"Konfigurasi 40 layer mencapai keseimbangan yang baik antara kekuatan bermain dan biaya pelatihan."}),"\n",(0,l.jsx)(a.h3,{id:"konfigurasi-konkret",children:"Konfigurasi Konkret"}),"\n",(0,l.jsx)(a.p,{children:"Konfigurasi ResNet AlphaGo Zero sebagai berikut:"}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{children:"Input: 17 x 19 x 19\n\u2193\nConv layer: 3x3, 256 channel, BN, ReLU\n\u2193\nResidual block x40:\n  \u251c\u2500 Conv layer: 3x3, 256 channel, BN, ReLU\n  \u251c\u2500 Conv layer: 3x3, 256 channel, BN\n  \u2514\u2500 Skip connection + ReLU\n\u2193\nPolicy Head / Value Head\n"})}),"\n",(0,l.jsx)(a.h4,{id:"estimasi-jumlah-parameter",children:"Estimasi Jumlah Parameter"}),"\n",(0,l.jsxs)(a.table,{children:[(0,l.jsx)(a.thead,{children:(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.th,{children:"Komponen"}),(0,l.jsx)(a.th,{children:"Jumlah Parameter (aprox.)"})]})}),(0,l.jsxs)(a.tbody,{children:[(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Input convolution"}),(0,l.jsx)(a.td,{children:"17 x 3 x 3 x 256 \u2248 39K"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Setiap residual block"}),(0,l.jsx)(a.td,{children:"2 x 256 x 3 x 3 x 256 \u2248 1.2M"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"40 residual block"}),(0,l.jsx)(a.td,{children:"40 x 1.2M \u2248 47M"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Policy Head"}),(0,l.jsx)(a.td,{children:"~1M"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Value Head"}),(0,l.jsx)(a.td,{children:"~0.2M"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:(0,l.jsx)(a.strong,{children:"Total"})}),(0,l.jsx)(a.td,{children:(0,l.jsx)(a.strong,{children:"~48M"})})]})]})]}),"\n",(0,l.jsx)(a.p,{children:"Sekitar 48 juta parameter, neural network skala menengah menurut standar modern."}),"\n",(0,l.jsx)(a.h3,{id:"peran-batch-normalization",children:"Peran Batch Normalization"}),"\n",(0,l.jsxs)(a.p,{children:["Setiap layer konvolusi diikuti ",(0,l.jsx)(a.strong,{children:"Batch Normalization (BN)"}),", ini krusial untuk stabilitas pelatihan:"]}),"\n",(0,l.jsx)(a.h4,{id:"1-normalisasi-nilai-aktivasi",children:"1. Normalisasi Nilai Aktivasi"}),"\n",(0,l.jsx)(a.p,{children:"BN menormalisasi nilai aktivasi setiap layer ke mean 0, variance 1:"}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{children:"x_hat = (x - \u03bc_B) / sqrt(\u03c3_B\xb2 + \u03b5)\ny = \u03b3 \xd7 x_hat + \u03b2\n"})}),"\n",(0,l.jsx)(a.p,{children:"Di mana \u03b3 dan \u03b2 adalah parameter yang bisa dipelajari."}),"\n",(0,l.jsx)(a.h4,{id:"2-mengurangi-internal-covariate-shift",children:"2. Mengurangi Internal Covariate Shift"}),"\n",(0,l.jsx)(a.p,{children:"Dalam deep network, distribusi input setiap layer berubah seiring update parameter layer sebelumnya. BN membuat distribusi input setiap layer tetap stabil, mempercepat konvergensi pelatihan."}),"\n",(0,l.jsx)(a.h4,{id:"3-efek-regularisasi",children:"3. Efek Regularisasi"}),"\n",(0,l.jsx)(a.p,{children:"BN menggunakan statistik mini-batch saat pelatihan, memperkenalkan randomness, memiliki efek regularisasi ringan."}),"\n",(0,l.jsx)(a.hr,{}),"\n",(0,l.jsx)(a.h2,{id:"perbandingan-dengan-arsitektur-lain",children:"Perbandingan dengan Arsitektur Lain"}),"\n",(0,l.jsx)(a.h3,{id:"vs-cnn-alphago-original",children:"vs. CNN AlphaGo Original"}),"\n",(0,l.jsxs)(a.table,{children:[(0,l.jsx)(a.thead,{children:(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.th,{children:"Fitur"}),(0,l.jsx)(a.th,{children:"AlphaGo Original"}),(0,l.jsx)(a.th,{children:"AlphaGo Zero"})]})}),(0,l.jsxs)(a.tbody,{children:[(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Tipe arsitektur"}),(0,l.jsx)(a.td,{children:"CNN standar"}),(0,l.jsx)(a.td,{children:"ResNet"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Kedalaman"}),(0,l.jsx)(a.td,{children:"13 layer"}),(0,l.jsx)(a.td,{children:"41-81 layer"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Residual connection"}),(0,l.jsx)(a.td,{children:"Tidak ada"}),(0,l.jsx)(a.td,{children:"Ada"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Jumlah network"}),(0,l.jsx)(a.td,{children:"2 (terpisah)"}),(0,l.jsx)(a.td,{children:"1 (shared)"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"BN"}),(0,l.jsx)(a.td,{children:"Tidak ada"}),(0,l.jsx)(a.td,{children:"Ada"})]})]})]}),"\n",(0,l.jsx)(a.h3,{id:"vs-network-gaya-vgg",children:"vs. Network Gaya VGG"}),"\n",(0,l.jsx)(a.p,{children:"VGG adalah arsitektur runner-up ImageNet 2014, menggunakan konvolusi 3x3 bertumpuk:"}),"\n",(0,l.jsxs)(a.table,{children:[(0,l.jsx)(a.thead,{children:(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.th,{children:"Fitur"}),(0,l.jsx)(a.th,{children:"VGG"}),(0,l.jsx)(a.th,{children:"ResNet"})]})}),(0,l.jsxs)(a.tbody,{children:[(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Kedalaman maksimum yang bisa dilatih"}),(0,l.jsx)(a.td,{children:"~19 layer"}),(0,l.jsx)(a.td,{children:"152+ layer"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Aliran gradien"}),(0,l.jsx)(a.td,{children:"Berkurang layer per layer"}),(0,l.jsx)(a.td,{children:"Ada highway"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Kesulitan pelatihan"}),(0,l.jsx)(a.td,{children:"Layer dalam sulit"}),(0,l.jsx)(a.td,{children:"Layer dalam bisa dilatih"})]})]})]}),"\n",(0,l.jsx)(a.h3,{id:"vs-inception--googlenet",children:"vs. Inception / GoogLeNet"}),"\n",(0,l.jsx)(a.p,{children:"Inception menggunakan konvolusi multi-skala paralel:"}),"\n",(0,l.jsxs)(a.table,{children:[(0,l.jsx)(a.thead,{children:(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.th,{children:"Fitur"}),(0,l.jsx)(a.th,{children:"Inception"}),(0,l.jsx)(a.th,{children:"ResNet"})]})}),(0,l.jsxs)(a.tbody,{children:[(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Keunggulan"}),(0,l.jsx)(a.td,{children:"Fitur multi-skala"}),(0,l.jsx)(a.td,{children:"Penumpukan dalam"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Kompleksitas"}),(0,l.jsx)(a.td,{children:"Lebih tinggi"}),(0,l.jsx)(a.td,{children:"Simpel"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Aplikabilitas Go"}),(0,l.jsx)(a.td,{children:"Biasa"}),(0,l.jsx)(a.td,{children:"Bagus"})]})]})]}),"\n",(0,l.jsx)(a.p,{children:"Desain simpel ResNet lebih cocok untuk Go yang membutuhkan penalaran dalam."}),"\n",(0,l.jsx)(a.h3,{id:"vs-transformer",children:"vs. Transformer"}),"\n",(0,l.jsx)(a.p,{children:"Arsitektur Transformer yang diajukan tahun 2017 meraih sukses besar di bidang NLP. Ada yang mencoba menerapkan Transformer ke Go:"}),"\n",(0,l.jsxs)(a.table,{children:[(0,l.jsx)(a.thead,{children:(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.th,{children:"Fitur"}),(0,l.jsx)(a.th,{children:"ResNet"}),(0,l.jsx)(a.th,{children:"Transformer"})]})}),(0,l.jsxs)(a.tbody,{children:[(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Inductive bias"}),(0,l.jsx)(a.td,{children:"Lokalitas (konvolusi)"}),(0,l.jsx)(a.td,{children:"Attention global"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Position encoding"}),(0,l.jsx)(a.td,{children:"Implisit (konvolusi)"}),(0,l.jsx)(a.td,{children:"Eksplisit"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Performa Go"}),(0,l.jsx)(a.td,{children:"Bagus"}),(0,l.jsx)(a.td,{children:"Bisa tapi tidak lebih baik dari ResNet"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Efisiensi komputasi"}),(0,l.jsx)(a.td,{children:"Lebih tinggi"}),(0,l.jsx)(a.td,{children:"Lebih rendah (O(n\xb2))"})]})]})]}),"\n",(0,l.jsx)(a.p,{children:"Untuk masalah seperti Go yang memiliki struktur spasial jelas, inductive bias CNN/ResNet lebih cocok."}),"\n",(0,l.jsx)(a.hr,{}),"\n",(0,l.jsx)(a.h2,{id:"analisis-mendalam-pilihan-desain",children:"Analisis Mendalam Pilihan Desain"}),"\n",(0,l.jsx)(a.h3,{id:"mengapa-menggunakan-konvolusi-3x3",children:"Mengapa Menggunakan Konvolusi 3x3?"}),"\n",(0,l.jsx)(a.p,{children:"AlphaGo Zero menggunakan konvolusi 3x3 secara konsisten, bukan kernel konvolusi lebih besar:"}),"\n",(0,l.jsxs)(a.ol,{children:["\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Efisiensi parameter"}),": Dua konvolusi 3x3 memiliki receptive field sama dengan satu 5x5, tapi jumlah parameter lebih sedikit (18 vs 25)"]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Network lebih dalam"}),": Dengan jumlah parameter sama, bisa menumpuk lebih banyak layer"]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Lebih banyak non-linearitas"}),": Ada ReLU antar layer, meningkatkan ekspresivitas"]}),"\n"]}),"\n",(0,l.jsx)(a.h3,{id:"mengapa-menggunakan-256-channel",children:"Mengapa Menggunakan 256 Channel?"}),"\n",(0,l.jsx)(a.p,{children:"256 channel adalah pilihan empiris:"}),"\n",(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Terlalu sedikit"})," (mis. 64): Ekspresivitas tidak cukup, tidak bisa menangkap pola kompleks"]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Terlalu banyak"})," (mis. 512): Jumlah parameter berlipat ganda, biaya pelatihan meningkat drastis, tapi peningkatan kekuatan terbatas"]}),"\n"]}),"\n",(0,l.jsx)(a.p,{children:"Eksperimen KataGo kemudian menunjukkan, jumlah channel bisa disesuaikan berdasarkan sumber daya pelatihan:"}),"\n",(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsx)(a.li,{children:"Sumber daya rendah: 128 channel, 20 block"}),"\n",(0,l.jsx)(a.li,{children:"Sumber daya tinggi: 256 channel, 40 block"}),"\n",(0,l.jsx)(a.li,{children:"Sumber daya lebih tinggi: 384 channel, 60 block"}),"\n"]}),"\n",(0,l.jsx)(a.h3,{id:"mengapa-policy-head-menggunakan-softmax-value-head-menggunakan-tanh",children:"Mengapa Policy Head Menggunakan Softmax, Value Head Menggunakan Tanh?"}),"\n",(0,l.jsx)(a.h4,{id:"policy-head-softmax",children:"Policy Head: Softmax"}),"\n",(0,l.jsxs)(a.p,{children:["Memainkan langkah adalah ",(0,l.jsx)(a.strong,{children:"masalah klasifikasi"}),"\u2014memilih satu dari 361 posisi (plus Pass). Output Softmax memenuhi:"]}),"\n",(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsx)(a.li,{children:"Semua probabilitas non-negatif: \u03c0_i >= 0"}),"\n",(0,l.jsx)(a.li,{children:"Jumlah probabilitas = 1: \u03a3\u03c0_i = 1"}),"\n"]}),"\n",(0,l.jsx)(a.p,{children:"Ini konsisten dengan definisi distribusi probabilitas."}),"\n",(0,l.jsx)(a.h4,{id:"value-head-tanh",children:"Value Head: Tanh"}),"\n",(0,l.jsxs)(a.p,{children:["Win rate adalah ",(0,l.jsx)(a.strong,{children:"masalah regresi"}),"\u2014memprediksi nilai kontinu. Range output Tanh adalah [-1, 1]:"]}),"\n",(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsx)(a.li,{children:"Bounded: Tidak akan menghasilkan nilai ekstrem"}),"\n",(0,l.jsx)(a.li,{children:"Simetris: Menang dan kalah ditangani secara simetris"}),"\n",(0,l.jsx)(a.li,{children:"Differentiable: Mudah untuk perhitungan gradien"}),"\n"]}),"\n",(0,l.jsx)(a.p,{children:"Menggunakan Tanh bukan output unbounded (seperti linear layer) bisa mencegah ketidakstabilan pelatihan."}),"\n",(0,l.jsx)(a.hr,{}),"\n",(0,l.jsx)(a.h2,{id:"detail-pelatihan",children:"Detail Pelatihan"}),"\n",(0,l.jsx)(a.h3,{id:"loss-function",children:"Loss Function"}),"\n",(0,l.jsx)(a.p,{children:"Total loss AlphaGo Zero adalah jumlah tiga term:"}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{children:"L = L_policy + L_value + L_reg\n"})}),"\n",(0,l.jsx)(a.h4,{id:"policy-loss",children:"Policy Loss"}),"\n",(0,l.jsxs)(a.p,{children:["Menggunakan ",(0,l.jsx)(a.strong,{children:"cross-entropy loss"}),", membuat output network mendekati probabilitas pencarian MCTS:"]}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{children:"L_policy = -\u03a3 \u03c0_MCTS(a) \xd7 log(\u03c0_net(a))\n"})}),"\n",(0,l.jsx)(a.p,{children:"Di mana:"}),"\n",(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsx)(a.li,{children:"\u03c0_MCTS(a) adalah probabilitas pencarian MCTS untuk aksi a"}),"\n",(0,l.jsx)(a.li,{children:"\u03c0_net(a) adalah probabilitas output network"}),"\n"]}),"\n",(0,l.jsx)(a.h4,{id:"value-loss",children:"Value Loss"}),"\n",(0,l.jsxs)(a.p,{children:["Menggunakan ",(0,l.jsx)(a.strong,{children:"Mean Squared Error (MSE)"}),", membuat output network mendekati hasil menang/kalah aktual:"]}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{children:"L_value = (v_net - z)\xb2\n"})}),"\n",(0,l.jsx)(a.p,{children:"Di mana:"}),"\n",(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsx)(a.li,{children:"v_net adalah win rate prediksi network"}),"\n",(0,l.jsx)(a.li,{children:"z adalah hasil pertandingan aktual (+1 atau -1)"}),"\n"]}),"\n",(0,l.jsx)(a.h4,{id:"regularization-loss",children:"Regularization Loss"}),"\n",(0,l.jsxs)(a.p,{children:["Menggunakan ",(0,l.jsx)(a.strong,{children:"L2 regularization"})," untuk mencegah overfitting:"]}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{children:"L_reg = c \xd7 ||\u03b8||\xb2\n"})}),"\n",(0,l.jsx)(a.p,{children:"Di mana c adalah koefisien regularisasi, \u03b8 adalah parameter network."}),"\n",(0,l.jsx)(a.h3,{id:"konfigurasi-optimizer",children:"Konfigurasi Optimizer"}),"\n",(0,l.jsxs)(a.table,{children:[(0,l.jsx)(a.thead,{children:(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.th,{children:"Parameter"}),(0,l.jsx)(a.th,{children:"Nilai"})]})}),(0,l.jsxs)(a.tbody,{children:[(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Optimizer"}),(0,l.jsx)(a.td,{children:"SGD + Momentum"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Momentum"}),(0,l.jsx)(a.td,{children:"0.9"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Learning rate awal"}),(0,l.jsx)(a.td,{children:"0.01"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Decay learning rate"}),(0,l.jsx)(a.td,{children:"Setengah setiap X langkah"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Batch Size"}),(0,l.jsx)(a.td,{children:"32 x 2048 = 64K (distributed)"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"Koefisien L2 regularization"}),(0,l.jsx)(a.td,{children:"1e-4"})]})]})]}),"\n",(0,l.jsx)(a.h3,{id:"data-augmentation",children:"Data Augmentation"}),"\n",(0,l.jsx)(a.p,{children:"Papan Go memiliki 8 simetri (4 rotasi x 2 flip). Saat pelatihan, setiap posisi bisa menghasilkan 8 sampel pelatihan ekuivalen."}),"\n",(0,l.jsx)(a.p,{children:"Ini membuat data pelatihan efektif meningkat 8 kali lipat, tanpa memerlukan self-play tambahan."}),"\n",(0,l.jsx)(a.hr,{}),"\n",(0,l.jsx)(a.h2,{id:"pertimbangan-implementasi",children:"Pertimbangan Implementasi"}),"\n",(0,l.jsx)(a.h3,{id:"optimisasi-memori",children:"Optimisasi Memori"}),"\n",(0,l.jsx)(a.p,{children:"Pelatihan 40-layer ResNet membutuhkan banyak memori:"}),"\n",(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Forward pass"}),": Perlu menyimpan nilai aktivasi setiap layer (untuk backpropagation)"]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Backward pass"}),": Perlu menyimpan gradien"]}),"\n"]}),"\n",(0,l.jsx)(a.p,{children:"Strategi optimisasi:"}),"\n",(0,l.jsxs)(a.ol,{children:["\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Gradient Checkpointing"}),": Hanya simpan sebagian nilai aktivasi, hitung ulang saat dibutuhkan"]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Mixed Precision Training"}),": Gunakan FP16 untuk mengurangi penggunaan memori"]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Distributed Training"}),": Sebarkan batch ke beberapa GPU/TPU"]}),"\n"]}),"\n",(0,l.jsx)(a.h3,{id:"optimisasi-inferensi",children:"Optimisasi Inferensi"}),"\n",(0,l.jsx)(a.p,{children:"Saat inferensi tidak perlu statistik mini-batch BN, bisa menggunakan moving average yang diakumulasi saat pelatihan:"}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{children:"x_hat = (x - \u03bc_moving) / sqrt(\u03c3_moving\xb2 + \u03b5)\n"})}),"\n",(0,l.jsx)(a.p,{children:"Ini membuat kecepatan inferensi lebih cepat dan hasil deterministik."}),"\n",(0,l.jsx)(a.h3,{id:"quantization-dan-compression",children:"Quantization dan Compression"}),"\n",(0,l.jsx)(a.p,{children:"Saat deployment bisa compress network lebih lanjut:"}),"\n",(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Weight Quantization"}),": FP32 \u2192 INT8, memori berkurang 4x"]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Pruning"}),": Hapus koneksi weight kecil"]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Knowledge Distillation"}),": Gunakan network besar untuk melatih network kecil"]}),"\n"]}),"\n",(0,l.jsx)(a.hr,{}),"\n",(0,l.jsx)(a.h2,{id:"korespondensi-animasi",children:"Korespondensi Animasi"}),"\n",(0,l.jsx)(a.p,{children:"Konsep inti yang dibahas dalam artikel ini dan nomor animasinya:"}),"\n",(0,l.jsxs)(a.table,{children:[(0,l.jsx)(a.thead,{children:(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.th,{children:"Nomor"}),(0,l.jsx)(a.th,{children:"Konsep"}),(0,l.jsx)(a.th,{children:"Korespondensi Fisika/Matematika"})]})}),(0,l.jsxs)(a.tbody,{children:[(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"E5 E3"}),(0,l.jsx)(a.td,{children:"Dual-head network"}),(0,l.jsx)(a.td,{children:"Multi-task learning"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"E5 D12"}),(0,l.jsx)(a.td,{children:"Residual connection"}),(0,l.jsx)(a.td,{children:"Highway gradien"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"E5 D8"}),(0,l.jsx)(a.td,{children:"Convolutional Neural Network"}),(0,l.jsx)(a.td,{children:"Receptive field lokal"})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:"E5 D10"}),(0,l.jsx)(a.td,{children:"Batch Normalization"}),(0,l.jsx)(a.td,{children:"Normalisasi distribusi"})]})]})]}),"\n",(0,l.jsx)(a.hr,{}),"\n",(0,l.jsx)(a.h2,{id:"bacaan-lanjutan",children:"Bacaan Lanjutan"}),"\n",(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Artikel Sebelumnya"}),": ",(0,l.jsx)(a.a,{href:"../alphago-zero",children:"Ikhtisar AlphaGo Zero"})," \u2014 Mengapa tidak memerlukan catatan permainan manusia"]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Artikel Berikutnya"}),": ",(0,l.jsx)(a.a,{href:"../training-from-scratch",children:"Proses Pelatihan dari Nol"})," \u2014 Evolusi detail Hari 0-3"]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Teknis Mendalam"}),": ",(0,l.jsx)(a.a,{href:"../cnn-and-go",children:"CNN dan Go"})," \u2014 Mengapa CNN cocok untuk papan"]}),"\n"]}),"\n",(0,l.jsx)(a.hr,{}),"\n",(0,l.jsx)(a.h2,{id:"referensi",children:"Referensi"}),"\n",(0,l.jsxs)(a.ol,{children:["\n",(0,l.jsxs)(a.li,{children:['Silver, D., et al. (2017). "Mastering the game of Go without human knowledge." ',(0,l.jsx)(a.em,{children:"Nature"}),", 550, 354-359."]}),"\n",(0,l.jsxs)(a.li,{children:['He, K., et al. (2016). "Deep Residual Learning for Image Recognition." ',(0,l.jsx)(a.em,{children:"CVPR 2016"}),"."]}),"\n",(0,l.jsxs)(a.li,{children:['Ioffe, S., & Szegedy, C. (2015). "Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift." ',(0,l.jsx)(a.em,{children:"ICML 2015"}),"."]}),"\n",(0,l.jsxs)(a.li,{children:['Caruana, R. (1997). "Multitask Learning." ',(0,l.jsx)(a.em,{children:"Machine Learning"}),", 28(1), 41-75."]}),"\n",(0,l.jsxs)(a.li,{children:['Veit, A., et al. (2016). "Residual Networks Behave Like Ensembles of Relatively Shallow Networks." ',(0,l.jsx)(a.em,{children:"NeurIPS 2016"}),"."]}),"\n"]})]})}function o(e={}){const{wrapper:a}={...(0,r.R)(),...e.components};return a?(0,l.jsx)(a,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},30416(e,a,n){n.d(a,{R:()=>s,x:()=>t});var i=n(59471);const l={},r=i.createContext(l);function s(e){const a=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function t(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),i.createElement(r.Provider,{value:a},e.children)}}}]);